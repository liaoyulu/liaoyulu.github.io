<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="YOLO">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;index.html">
<meta property="og:site_name" content="YOLO">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>YOLO</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">YOLO</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/20/%E7%AC%AC%E4%B8%89%E5%8D%83%E6%AC%A1%E6%83%B3%E8%A6%81%E8%8E%B7%E5%BE%97%E6%96%B0%E7%94%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YOLO">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/20/%E7%AC%AC%E4%B8%89%E5%8D%83%E6%AC%A1%E6%83%B3%E8%A6%81%E8%8E%B7%E5%BE%97%E6%96%B0%E7%94%9F/" itemprop="url">第三千次想要获得新生</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-20T23:59:50+08:00">
                2020-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为什么叫第三千次想要获得新生呢？原因很明显，因为拖延。前天老板问了问我们大二的学生的想法，感觉又可以再振作起来了，我姑且称之为第2999次新生orz。</p>
<h2 id="对于过去和现在的一些反思"><a href="#对于过去和现在的一些反思" class="headerlink" title="对于过去和现在的一些反思"></a>对于过去和现在的一些反思</h2><p>现在已经是开学后的第五周了<br>从九个月前的寒假开始，我好像进入了低谷期，因为疫情原因长时间滞留在家里。其实现在我觉得可能还在往下走（低谷期也太长了吧啊喂）,前几天拔了牙，现在非常得有缺失感，上课注意力无法集中，要么睡觉要么玩手机，很痛苦，甚至怀疑自己患上了什么精神上的疾病。好像我也只能拿生病当借口。<br>首先是寒假minipoject的惨烈，然后是学业上的，再又开始了现在身体精神上的折磨。所以非常非常感谢有人能在这个时候多鼓励鼓励我或者是引导我。<br>再说下去就变成了一篇抱怨自责日记了。下面想讲讲自己现在突然意识到的问题和解决办法？ </p>
<h2 id="关于我的博客"><a href="#关于我的博客" class="headerlink" title="关于我的博客"></a>关于我的博客</h2><p>大一上学期的时候在学长学姐的催促下，以及对成功进入木犀团队的渴望，我草草地搭建了自己的hexo博客，还记得那个时候怎么也弄不成，因为什么进度条怎么也不懂，等了几个小时还是失败率，最终依靠一行 npm cache clean –force解决了一切，关于这种奇奇怪怪的问题无数次打扰鱼红旗学长（学长yyds）。赶在ddl之前搭建好博客，但也实在是不想再继续重新配置了于是我的博客长得比别人朴素了许多。这是我需要反思的地方。<br><img src="/2020/10/20/%E7%AC%AC%E4%B8%89%E5%8D%83%E6%AC%A1%E6%83%B3%E8%A6%81%E8%8E%B7%E5%BE%97%E6%96%B0%E7%94%9F/%E5%8E%9F%E5%A7%8B.png" alt="yolo&#39;s blog"><br><img src="/2020/10/20/%E7%AC%AC%E4%B8%89%E5%8D%83%E6%AC%A1%E6%83%B3%E8%A6%81%E8%8E%B7%E5%BE%97%E6%96%B0%E7%94%9F/%E5%8E%9F%E5%A7%8B2.png" alt="yolo&#39;s blog"><br>没有侧边栏，甚至点进喂二的两个图标进去之后是404；捂脸<br><strong>然后是博客的内容</strong> 这是我非常自责的一部分。因为前端组内有分享的任务，绝大多数博客都是直接复制粘贴别人的或者书上抄下来的，有些博客质量也不堪入目。所以在之后我应该会删除掉一些不属于我的东西，好好重新打理一下我的博客。<br>（该死的注意力，去差个MarkDown的功夫又看起了社会新闻  </p>
<blockquote>
<p>来自老板的解读<br>博客则是对知识点或者技术学习的比较正式的总结或者分享，是个人的技术专栏，代表你个人的技术探索和沉淀。</p>
</blockquote>
<p>我希望我的博客，能拥有自己的东西，能表达出我对技术的探索和思考。</p>
<h4 id="总结们"><a href="#总结们" class="headerlink" title="总结们"></a>总结们</h4><p>从博客的新生联想到关于总结的一些东西。<br>知识要有收获也应该有产出，那么知识才能最终属于自己，而不是知道个大概也讲不清。同时，它也起到的备忘录的功能，正所谓好记性不如烂笔头。</p>
<ul>
<li>在哪里做总结<br>我的博客，github读书笔记，知乎专栏，掘金文章，公众号，工作台进度</li>
<li>如何做总结  <ul>
<li>技术笔记：对日常学习的记录 （原创内容较少<br>关键是用自己的思路结合自己的语言去表达而不是复制粘贴—&gt;利于表达清楚，真正理解<ul>
<li>读书笔记：按章节进行总结  </li>
<li>某个比较难的知识点的学习记录</li>
</ul>
</li>
<li>技术博客：实践与思考<ul>
<li>项目总结</li>
<li>实践</li>
<li>技术专题研究</li>
<li>系统的解决方案</li>
<li>个人感悟</li>
</ul>
</li>
<li>去看看别人是怎么写博客的⑧<ul>
<li>看看页面，了解一下其他文章</li>
</ul>
</li>
<li>语文功底？（有点奇怪的感觉<ul>
<li>文学作品</li>
<li>学习优秀技术文章的写作方法。  </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>通过文字表达自己的思想。</p>
<h2 id="关于拖延"><a href="#关于拖延" class="headerlink" title="关于拖延"></a>关于拖延</h2><p>首先首先，想要一个好的作息，好的身体，这段时间对身体的打击实在有点大，所以，我先睡了。</p>
<ul>
<li>好好打理自己的github，每天都要有产出。</li>
<li>每天都应该有收获，细水长流</li>
<li>克服寝室的诱惑</li>
<li>就算做不到也要写计划。（如何写计划）<h2 id="关于计划"><a href="#关于计划" class="headerlink" title="关于计划"></a>关于计划</h2>对未来有良好的规划是一件很美好的事情，做好一件事的满足感是很强大的，会让你很开心。<br>要好好学英语，要好好写代码，要考试，学习计算机基础。</li>
</ul>
<p>最后，希望能够保持热情，要快乐啊！！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/17/CSSOM/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YOLO">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/17/CSSOM/" itemprop="url">CSSOM</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-17T09:21:29+08:00">
                2020-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="初探CSS对象模型（CSSOM）"><a href="#初探CSS对象模型（CSSOM）" class="headerlink" title="初探CSS对象模型（CSSOM）"></a>初探CSS对象模型（CSSOM）</h2><h2 id="CSSOM是什么？"><a href="#CSSOM是什么？" class="headerlink" title="CSSOM是什么？"></a>CSSOM是什么？</h2><p>CSSOM是一组允许JavaScript操作CSS的API。它非常类似于DOM，但是用于CSS而不是HTML。它允许用户动态读取和修改CSS样式。</p>
<p>CSSOM在W3C规范中有一个独立的模块，对于我们学习CSSOM还是很有帮助的，但相较于MDN而来，更难于阅读和理解。</p>
<p>为了更好的理解CSSOM是什么？我来们先来看一个简单的示例。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="selector-tag">DOCTYPE</span> <span class="selector-tag">html</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">html</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">head</span>&gt;</span><br><span class="line">        &lt;meta name="viewport" content="width=device-width,initial-scale=1"&gt;</span><br><span class="line">        &lt;link href="style.css" rel="stylesheet"&gt;</span><br><span class="line">        &lt;title&gt;Critical Path&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;<span class="selector-tag">body</span>&gt;</span><br><span class="line">        &lt;p&gt;Hello &lt;span&gt;web performance&lt;/span&gt; students!&lt;/p&gt;</span><br><span class="line">        &lt;div&gt;&lt;img src="awesome-photo.jpg"&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line">// style.css</span><br><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">16px</span> </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123; </span><br><span class="line">    <span class="attribute">font-weight</span>: bold </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">span</span> &#123; </span><br><span class="line">    <span class="attribute">color</span>: red </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> <span class="selector-tag">span</span> &#123; </span><br><span class="line">    <span class="attribute">display</span>: none </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">img</span> &#123; </span><br><span class="line">    <span class="attribute">float</span>: right </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个非常简单的Web页面，“包含了一些文本和一幅图片”。浏览器处理这个页面的过程如下：<br><img src="/2020/10/17/CSSOM/cssom-3.png" alt="处理过程"><br>根据前面所学，其对应的DOM结构建如下：<br><img src="/2020/10/17/CSSOM/cssom-4.png" alt="dom构建"></p>
<p>对于Web的样式，其处理HTML有点类似，需要将收到的CSS规则转换成某种浏览器能够理解和处理的东西。因此，我们会重复HTML过程，只不过是为CSS而不是HTML:<br><img src="/2020/10/17/CSSOM/cssom-5.png" alt="处理过程"></p>
<p>CSS字节转换成字符，接着转换成令牌和节点，最后链接到一个CSSOM的树结构中：<br><img src="/2020/10/17/CSSOM/cssom-6.png" alt="处理过程"></p>
<p>是不是看上去和DOM结构树类似呀。那么CSSOM为何具有树结构呢？为页面上的任何对象计算最后一组样式时，浏览器都会先从适用于该节点的最通用规则开始，比如，如果该节点是body元素的子元素，则应用所有body样式，然后通过应用更具体的规则（这里将会运用CSS层级相关的管理规则）以递归方式优化计算的样式。</p>
<p>上面的示例就很形象的介绍了CSSOM。</p>
<blockquote>
<p>注意，上图显示的树并非是一颗完整的CSSOM树，它只显示了我们决定在样式表中替换的样式。</p>
</blockquote>
<p>事实上这一过程是相当复杂的过程，在这里不做过多的介绍，如果你感兴趣的话，可以看其他文章</p>
<h2 id="使用ele-style设置元素行内样式"><a href="#使用ele-style设置元素行内样式" class="headerlink" title="使用ele.style设置元素行内样式"></a>使用ele.style设置元素行内样式</h2><p>在Web开发中，我们有的时候需要动态的控制HTML元素的样式，对于这样的场景，大多数都是通过JavaScript的API来控制HTML的style属性。面对这样的场景是使用ele.style这个API来控制style对象。我们可以通过在浏览器的控制台中，输入$0.style可以输出对应元素的style所对应的属性：</p>
<p><img src="/2020/10/17/CSSOM/cssom-1.png" alt="处理过程"><br>比如我们要修改表单元素input的背景颜色，我们可以这么做：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$0.style.backgroundColor='green'</span><br></pre></td></tr></table></figure>
<p>这样元素input自动加下了style属性，而且值为background-color: green。同时表单的背景颜色变成了green：</p>
<p><img src="/2020/10/17/CSSOM/cssom-2.png" alt="处理过程"></p>
<blockquote>
<p>$0是浏览器调试器中的一个技巧，指定是选择中的元素。在实际使用的时候，可以通过JavaScript选择器相关的API来获取你想要的DOM元素。最为常见的就是使用getElement* 和 querySelector* API，有关于这方面更为详细的介绍，可以<br>查资料</p>
</blockquote>
<p>也就是说，我们可以使用相同的格式添加或更改页面上任何对象的CSS：ele.style.propertyName，其中ele指的是DOM元素，propertyName指的是希望给ele元素要添加的样式属性（记住，带有-中划线的CSS属性需要改用陀峰形式，比如上面示例中的background-color属性要写成backgroundColor）。</p>
<blockquote>
<p>注意，在动态设置float属性时，需要使用cssFloat，这是因为float是JavaScript中的一个关键词。这个有点类似于getAttribute()给HTML元素设置for属性时，需要使用htmlFor。</p>
</blockquote>
<p>这种方式是使用JavaScript给DOM元素设置样式最简单的方法。但是以这种方式给DOM元素设置样式有一个最大的局限性：只能给DOM元素添加内联样式。同样的，如果我们想获取一个DOM元素的内联样式中某个属性的值时，也可以采用这种方式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$0.style.backgroundColor // =&gt; green</span><br></pre></td></tr></table></figure>
<p>当然，通过上面方式获取DOM元素内联样式对应属性的值时，有个前提条件，那就是该元素定义了该内联样式。如果未指定（定义）该样式，那么将不会返回任何值：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$0.style.color // =&gt; ""</span><br></pre></td></tr></table></figure>
<p>在CSS Houdini中的CSSOM，我们可以使用.attributeStyleMap属性来替代ele.style。可以使用ele.attributeStyleMap.set(property, value)来设置元素内联样式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$0.attributeStyleMap.set('background-color', 'green')</span><br></pre></td></tr></table></figure>
<p>其得到的效果和ele.style.property = value等同的效果。另外，.attributeStyleMap类似于Map对象，所以它们支持对象常有的一些方法，比如get、set、keys、values和entry等。这样让我们的工作也变得更为灵活：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$0.attributeStyleMap.set('background-color', 'green') // 设置background-color的值为green</span><br><span class="line">$0.attributeStyleMap.get('background-color').value === 'green' // =&gt; false</span><br><span class="line">$0.attributeStyleMap.has('background-color') // =&gt; true</span><br><span class="line">$0.attributeStyleMap.delete('background-color') // =&gt; 删除background-color</span><br><span class="line">$0.attributeStyleMap.clear() // =&gt; 删除所有样式</span><br></pre></td></tr></table></figure>
<h2 id="获取计算样式"><a href="#获取计算样式" class="headerlink" title="获取计算样式"></a>获取计算样式</h2><p>我们可以使用window.getComputedStyle()方法获取元素上任何CSS的计算值。<br><img src="/2020/10/17/CSSOM/cssom-7.png" alt="处理过程"></p>
<p>在浏览器的Computed一项中，我们可以查看到任何元素具有的可计算的样式。如上图所示。那么我们可以通过window.getComputedStyle()方法获取相应的计算样式，比如像下面这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.getComputedStyle($0).backgroundColor // =&gt; "rgb(0, 128, 0)"</span><br></pre></td></tr></table></figure>
<p>上面只是获取了其中一个计算样式值。除了上述的方式，我们还可以通过其他的方式来获取，比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">window</span><span class="selector-class">.getComputedStyle</span>(<span class="selector-tag">el</span>)<span class="selector-class">.backgroundColor</span>;</span><br><span class="line"><span class="selector-tag">window</span><span class="selector-class">.getComputedStyle</span>(<span class="selector-tag">el</span>)<span class="selector-attr">['background-color']</span>;</span><br><span class="line">window.getComputedStyle(el).getPropertyValue('background-color');</span><br></pre></td></tr></table></figure>
<p>而在新的CSSOM中有一个新的API，可以让我们获取计算值。比如：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">el.computedStyleMap().get('opacity').value // =&gt; 0.5</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，window.getComputedStyle()和ele.computedStyleMap()的差别是，前者返回的是解析值，而后值返回计算值。类如，如果你的样式中有一个这样的值，width: 50%，那么在Typed OM中将保留百分值（width: 50%）;而CSSOM中返回的是解析值（width: 200px）。</p>
</blockquote>
<p>上面示例中，window.getComputedStyle()方法只传了一个参数，对于普通元素可以省略第二个参数，或者显示的传一个null值：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">window</span><span class="selector-class">.getComputedStyle</span>(<span class="selector-tag">ele</span>, <span class="selector-tag">null</span>)<span class="selector-class">.property</span>;</span><br></pre></td></tr></table></figure>
<p>其实，它有一个小细节，它允许你检索伪元素的样式信息：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.getComputedStyle(ele, '::before').property;</span><br></pre></td></tr></table></figure>
<h2 id="CSSStyleDeclaration-相关API"><a href="#CSSStyleDeclaration-相关API" class="headerlink" title="CSSStyleDeclaration 相关API"></a>CSSStyleDeclaration 相关API</h2><p>通过前面的内容我们知道如何通过style对象或使用getComputedStyle()访问样式属性，这两个其实是CSSStyleDeclaration接口。也就是说，我们可以像下面这样将body元素上返回一个CSSStyleDeclaration对象：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">document</span><span class="selector-class">.body</span><span class="selector-class">.style</span>;</span><br><span class="line"><span class="selector-tag">window</span><span class="selector-class">.getComputedStyle</span>(<span class="selector-tag">document</span><span class="selector-class">.body</span>);</span><br></pre></td></tr></table></figure>
<p>我们可以在浏览器控制台中看到上面的命令将会输出的内容：</p>
<p><img src="/2020/10/17/CSSOM/cssom-8.png" alt="处理过程"></p>
<p>这两者有点不同，前者其实是前面介绍的ele.style，它可以获取和设置元素CSS属性的值，只不过只是给元素添加内联样式；但window.getComputedStyle(ele)获取的是只读值。</p>
<p>CSSStyleDeclaration有几个常用的方法：</p>
<p>setProperty()：给一个声明了CSS样式的对象设置一个新的值<br>getPropertyValue()：用来获取CSS属性的值<br>item()：通过下标从CSSStyleDeclaration返回一个CSS属性值<br>getPropertyPriority()：根据传入的CSS属性，返回一个DOMString来表示该属性的权重（优先级）<br>removeProperty()：移除style对象的一个属性<br>接下来分别看这几个方法是如何使用的。</p>
<h2 id="setProperty"><a href="#setProperty" class="headerlink" title="setProperty()"></a>setProperty()</h2><p>该方法可以给CSS的属性设置一个新的值。可以像下面这样使用：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ele</span><span class="selector-class">.style</span><span class="selector-class">.setProperty</span>(<span class="selector-tag">property</span>, <span class="selector-tag">value</span>, <span class="selector-tag">priority</span>)</span><br></pre></td></tr></table></figure>
<p>其中property指的是CSS属性，value设置的属性的值，priority允许设置CSS的权重，即!important。比如下面这个示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$0.style.setProperty('color', 'red')</span><br><span class="line"></span><br><span class="line">window.getComputedStyle($0).color  // =&gt; "rgb(255, 0, 0)"</span><br></pre></td></tr></table></figure>
<h2 id="getPropertyValue"><a href="#getPropertyValue" class="headerlink" title="getPropertyValue()"></a>getPropertyValue()</h2><p>该方法可以用来获取CSS属性的值，比如像下面这样：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$0.style.getPropertyValue('color')  // =&gt; "red"</span><br></pre></td></tr></table></figure>
<p>使用该方法时，如果getComputedStyle没有给元素指定属性时，它将返回一个空字符串：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$0.style.getPropertyValue('background-color') // =&gt; ""</span><br></pre></td></tr></table></figure>
<h2 id="item"><a href="#item" class="headerlink" title="item()"></a>item()</h2><p>在CSSStyleDeclaration的item()方式可以让我们通过下标从CSSStyleDeclaration返回一个CSS属性值。其使用格式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ele</span><span class="selector-class">.style</span><span class="selector-class">.item</span>(<span class="selector-tag">index</span>)</span><br></pre></td></tr></table></figure>
<p>其中index是需要查找节点的索引，索引下标从0开始。如果我们要获取元素行内样式中所有的属性时可以通过下面的方式遍历出来：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; $0.style.length; i++) &#123;</span><br><span class="line">    console.log($0.style.item(i))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// =&gt; clear</span><br><span class="line">// =&gt; position</span><br><span class="line">// =&gt; zoom</span><br></pre></td></tr></table></figure>
<p>这里有一个小细节，item()方法只要传入参数，这个方法就不会抛出异常，当传入的下标越界时会返回空字符串，当未传入参数时会抛出一个TypeError。</p>
<p><img src="/2020/10/17/CSSOM/cssom-9.png" alt="处理过程"></p>
<h2 id="getPropertyPriority"><a href="#getPropertyPriority" class="headerlink" title="getPropertyPriority()"></a>getPropertyPriority()</h2><p>getPropertyPriority()方法是一个很有意思的方法。这个方法会根据传入的CSS属性，返回一个DOMString来表示该属性的优先级。如果有的话，则返回important；如果不存在的话，返回空字符串。</p>
<p>在介绍style.setProperty()方法的时候，我们在给其传参数的时候，第三个参数就可以指定属性的优先级。或者在原有的CSS中带有!important时，该方法也会返回important字符串。比如下面这个小示例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$0.style.setProperty('border', '2px solid red', 'important')</span><br><span class="line">$0.style.setProperty('background-color', 'orange')</span><br><span class="line"></span><br><span class="line">$0.style.getPropertyPriority('border')                // =&gt; "important"</span><br><span class="line">$0.style.getPropertyPriority('background-color')      // =&gt; ""</span><br></pre></td></tr></table></figure>
<p>上面的示例中，第一行代码和第二行代码使用了ele.style.setProperty()方式给元素分别设置了border和background-color两个属性，不同之处是，第一个传了第三个参数priority（即”important”）。这个参数就相当于在给属性值后面附加了!important关键字。</p>
<p><img src="/2020/10/17/CSSOM/cssom-10.png" alt="处理过程"></p>
<p>在用!important设置属性之后，使用ele.style.getPropertyPriority()方法检查该属性的优先级。前面也提到过了，如果元素的style中的属性带有!important值，也可以使用该方法进行检查。</p>
<p>这里有一个小细节需要注意，如果内联样式中的简写属性，比如margin属性值带有!important关键词，如果我们使用ele.style.getPropertyPriority()在检查简写属性或示简写的属性的时，都将返回important的值。比如下面的代码：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$0.style.getPropertyPriority('margin')       // =&gt;  "important"</span><br><span class="line">$0.style.getPropertyPriority('margin-top')   // =&gt;  "important"</span><br><span class="line">$0.style.getPropertyPriority('margin-right') // =&gt;  "important"</span><br><span class="line">$0.style.getPropertyPriority('margin-bottom')// =&gt;  "important"</span><br><span class="line">$0.style.getPropertyPriority('margin-left')  // =&gt;  "important"</span><br></pre></td></tr></table></figure>
<h2 id="removeProperty"><a href="#removeProperty" class="headerlink" title="removeProperty()"></a>removeProperty()</h2><p>该方法可以移除style对象的一个属性：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$0.style.removeProperty('margin')    // =&gt; ""</span><br><span class="line">$0.style.getPropertyValue('margin')  // =&gt; ""</span><br></pre></td></tr></table></figure>
<p>这个时候，DOM元素中style里的margin属性被移除了，比如下图所示的结果：</p>
<p><img src="/2020/10/17/CSSOM/cssom-11.png" alt="处理过程"></p>
<h2 id="CSSStyleSheet接口"><a href="#CSSStyleSheet接口" class="headerlink" title="CSSStyleSheet接口"></a>CSSStyleSheet接口</h2><p>前面我们所聊的内容大部分都是关于元素内联样式（通常局限性较大）和计算样式（通常很有用，但过于具体）。接下来要聊的CSSStyleSheet相关的API是一个更有用的API，它允许检索具有可读和可写值的样式表，而不仅仅是内联样式表。简单地说，该接口代表一个单一的CSS样式表。</p>
<p>在写Web页面的时候，我们一直都提倡将页面的样式规则放入到一个单一（或多个）样式文件中，或者 标签中。这两种方式写样式都会包含一组CSS规则。每条CSS规则可以通过与之相关联的对象进行操作，这个关联对象实现了CSSStyleRule接口，而CSSStyleRule反过来实现了CSSRule。CSSStyleSheet允许你检测与修改和它相关联的的样式表，包括样式表的规则列表。</p>
<p>实际上，CSSStyleSheet也实现了更为通用的StyleSheet接口。实现一个document的样式表的CSSStyleSheet列表可以过document.styleSheet属性获取(这个document通过外联样式表或内嵌的style元素定义样式)。</p>
<p>比如，我们可以使用下面的方式来查看一个页面（文档）中有多少样式表：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.styleSheets.length  // =&gt; 5</span><br></pre></td></tr></table></figure>
<p>上面代码查询出W3cplus网站总共用了多少个CSS样式表（样式文件）：</p>
<p><img src="/2020/10/17/CSSOM/cssom-12.png" alt="处理过程"></p>
<p>同样的，我们可以使用下标索引引用文档中的任何样式表，比如：</p>
<p><img src="/2020/10/17/CSSOM/cssom-13.png" alt="处理过程"></p>
<p>我们也可遍历出来所有运用到的样式表的相关信息：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(let i = 0; i &lt; document.styleSheets.length; i++) &#123;</span><br><span class="line">    <span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">document</span><span class="selector-class">.styleSheets</span><span class="selector-attr">[i]</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/17/CSSOM/cssom-14.png" alt="处理过程"><br>在上面两个截图中，我们都可以看到cssRules和ownerRule两个属性：</p>
<ul>
<li>cssRules：返回样式表中CSS规则的CSSRuleList对象</li>
<li>ownerRule：如果一个样式表示通过@import规则引入document的，则ownerRule将返回那个CSSImportRule对象，否则返回null<br>其中cssRules属性是较为有用的。此属性提供样式表中包含的所有CSS规则（包括声明块、at-rules和媒体查询等）的列表。</li>
</ul>
<p><img src="/2020/10/17/CSSOM/cssom-15.png" alt="处理过程"></p>
<p>在这个示例中，总共有116个CSS规则。</p>
<p>在接下来的部分中，我们将详细介绍如何使用这个API来操作和读取外部样式表中的样式。比如我们要把第一个.css文件中所有选择器打印出来，我们就可以像下面这样做：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let myRules = document.styleSheets[0].cssRules</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">for</span> (<span class="selector-tag">i</span> <span class="selector-tag">of</span> <span class="selector-tag">myRules</span>) &#123;</span><br><span class="line">    if (i.type === 1) &#123;</span><br><span class="line">        <span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">i</span><span class="selector-class">.selectorText</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出来的结果类似下图这样：</p>
<p><img src="/2020/10/17/CSSOM/cssom-16.png" alt="处理过程"></p>
<p>在上面的代码中需要注意两件事。首先，把第一个样式表中的cssRules对象赋值给一个变量缓存起来，然后使用for… of循环来循环该对象中的所有规则，检查每个规则的类型。在这种情况之下，我们需要的规则类型(type)是1，它表示STYLE_RULE常量。其他常量包括IMPORT_RULE(对应的type = 3)、MEDIA_RULE（对应的type=4）和KEYFRAMES_RULE（对应的type=7）。更多的类型如下图所示，也可以在MDN上查阅：</p>
<p><img src="/2020/10/17/CSSOM/cssom-17.png" alt="处理过程"></p>
<p>同样的，我们可以使用类似的方法打印出@media和@keyframes里面相关的信息。也可以以类似方式打印出类似selectorText相关的信息，比如style、styleMap和cssText等。比如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let myRules = document.styleSheets[0].cssRules</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">for</span> (<span class="selector-tag">i</span> <span class="selector-tag">of</span> <span class="selector-tag">myRules</span>) &#123;</span><br><span class="line">    if (i.type === 1) &#123;</span><br><span class="line">        <span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">i</span><span class="selector-class">.cssText</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印出来的结果类似下图：<br><img src="/2020/10/17/CSSOM/cssom-18.png" alt="处理过程"></p>
<p>在CSSStyleSheet接口中除了上面提到的两个常见属性之外，还有两个方法，允许你从样式表中添加或删除整个规则。</p>
<ul>
<li>insertRule：向样式表中插入一条新规则</li>
<li>deleteRule：从当前样式表对象中删除指定的样式规则<br>比如我们要给第一个样式表中添加一条新的样式规则：<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let firstStylesheet = document.styleSheets[0]</span><br><span class="line">console.log(firstStylesheet.cssRules.length)  // =&gt; 116</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">firstStylesheet</span><span class="selector-class">.insertRule</span>(</span><br><span class="line">    `<span class="selector-tag">body</span> &#123;</span><br><span class="line">        <span class="attribute">background-color</span>: orange;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">        <span class="attribute">padding</span>: <span class="number">2em</span>;</span><br><span class="line">    &#125;`,</span><br><span class="line">    <span class="selector-tag">firstStylesheet</span><span class="selector-class">.cssRules</span><span class="selector-class">.length</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
这个时候在样式表中添加了下面的样式：</li>
</ul>
<p><img src="/2020/10/17/CSSOM/cssom-19.png" alt="处理过程"></p>
<p>我也可以通过下面的代码，来验证：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">for</span> (<span class="selector-tag">i</span> <span class="selector-tag">of</span> <span class="selector-tag">firstStylesheet</span><span class="selector-class">.cssRules</span>) &#123;</span><br><span class="line">    if (i.type === 1) &#123;</span><br><span class="line">        <span class="selector-tag">console</span><span class="selector-class">.log</span>(<span class="selector-tag">i</span><span class="selector-class">.cssText</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/17/CSSOM/cssom-20.png" alt="处理过程"></p>
<p>其cssRules的length值由116变成117：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(firstStylesheet.cssRules.length)   // =&gt; 117</span><br></pre></td></tr></table></figure>
<p>stylesheet.insertRule()方法接受两值参数：</p>
<p>rule：一个字符串，也就是想插入的样式规则，包含选择器和对应的样式规则<br>index：一个数字，表示要插入的位置，这是一个可选参数<br>注意，对于普通样式规则来说,要插入的字符串应该包含选择器和样式声明。对于@规则来说，要插入的字符串应该包含@标识符和样式规则的内容。另外，index未设置的话，则默认为0，新添加的rule将会插入到样式表的最前面，如果index索引值恰好大于cssRules.length，将会抛出一个错误。</p>
<p>deleteRule()方法相对来说更为容易，它只接受一个参数index。index就是一个数字，用来指定样式规则的位置。作为参数传入的所选index必须小于cssRules.length，否则将抛出错误。比如我们现在要删除刚才新增加的样式规则：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">3em</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们就可以像下面这样来删除这条规则：</p>
<p>firstStylesheet.deleteRule(116)<br>对应的样式规则就删除了。如果把116换成117就会报错：</p>
<p>CSSOM的未来<br>在介绍ele.style这个API的时候，简单的提到过，CSS Houdini中提到了新的CSSOM（即CSS Typed OM）。新的CSSOM相关的API能提供更大的优势。有关于这方面的介绍，可以阅读Google开发者文档中@Eric Bidelman写的博文。</p>
<p>总结<br>通过JavaScript中的相关API来操作CSS样式表肯定不是每个项目中都会用到的。但文章中提到的一些API的的确确可以帮助我们实现一些复杂交互。因此，掌握这些API是很有必要的，同时能加强我们处理业务的能力。</p>
<p>摘自<br><a href="https://www.w3cplus.com/javascript/cssom-css-typed-om.html?expire=1602900823&code=xlbFpB4A76Q&sign=dacc0e20f3ecd9b1242729e38fd44687#paywall" target="_blank" rel="noopener">原文</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/16/js%E8%87%AA%E6%B5%8B%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YOLO">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/16/js%E8%87%AA%E6%B5%8B%E9%A2%98/" itemprop="url">js自测题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-16T16:05:43+08:00">
                2020-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;<span class="comment">//定义一个构造函数</span></span><br><span class="line">a.b = <span class="number">1</span></span><br><span class="line">a.prototype.b = <span class="number">2</span><span class="comment">//原型对象的b属性为2</span></span><br><span class="line">a.prototype.c = <span class="number">3</span></span><br><span class="line">a.prototype.d = <span class="number">4</span></span><br><span class="line"><span class="built_in">console</span>.log(a.b)<span class="comment">// 1 对象a的b属性为1 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> a().b)<span class="comment">//2 构造函数返回对象实例继承原型b属性为2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> a()<span class="comment">//创建一个对象实例</span></span><br><span class="line">foo.c = <span class="number">5</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.c)<span class="comment">//5 </span></span><br><span class="line"><span class="built_in">console</span>.log(foo.d)<span class="comment">//4</span></span><br></pre></td></tr></table></figure>
<h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Foo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a = <span class="number">1</span><span class="comment">//this指向新创建的对象</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    a:<span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bar = <span class="keyword">new</span> Foo()</span><br><span class="line"><span class="built_in">console</span>.log(bar.a)<span class="comment">//2 如果返回值是一个对象，那么this指向的就是那个返回的对象，如果返回值不是一个对象那么this还是指向函数的实例。</span></span><br></pre></td></tr></table></figure>
<h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="built_in">Object</span>.create(<span class="literal">null</span>);<span class="comment">//使用null原型创建原型对象 原型污染无法影响这样的对象。 </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> map);<span class="comment">//false null原型没有toString方法 空对象没有原型连</span></span><br><span class="line"><span class="keyword">var</span> map = <span class="built_in">Object</span>.create(&#123;<span class="attr">a</span>:<span class="number">1</span>&#125;);<span class="comment">//&#123;a:1&#125;新创建对象的原型对象。</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> map); <span class="comment">//true  toString是Object的原型办法</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"a"</span> <span class="keyword">in</span> map); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>,<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请说明函数foo的作用<br><a href="https://www.cnblogs.com/SallyShan/p/11530619.html" target="_blank" rel="noopener">参考</a><br>foo作用：准确判断数据类型。<br>toString :把一个逻辑值转换成字符串并返回结果<br>call(): 改变this指向<br>slice():返回一个新的数组，包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</p>
<h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line">a.bar = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, <span class="string">"foo"</span>,</span><br><span class="line">                      &#123; <span class="attr">value</span>: <span class="string">"hi"</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> a.foo)<span class="comment">//False configurable默认False，不能直接删除当前的属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">delete</span> a.bar)<span class="comment">//true  </span></span><br><span class="line"></span><br><span class="line">a.foo = <span class="string">"world"</span></span><br><span class="line"><span class="built_in">console</span>.log(a.foo)<span class="comment">//hi 数据描述符vale和writable writable默认false，不能改变value</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> a)&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key);<span class="comment">//没有输出 enumerable描述属性是否出现在for in或者object.keys()的遍历中 foo默认false bar被delete</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"foo"</span> <span class="keyword">in</span> a);<span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"bar"</span> <span class="keyword">in</span> a);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>object.defineProperty(obj.prop.desc)<br>作用：直接在一个对象上定义一个新属性，或者修改一个已存在的属性。</p>
</blockquote>
<ol>
<li><p>obj 需要定义属性的当前对象</p>
</li>
<li><p>prop 当前需要定义的属性名</p>
</li>
<li><p>desc 属性描述符</p>
<h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a;<span class="comment">//变量声明提升</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">test(); <span class="comment">//0 |1:this最终指向的是调用它的对象,这里的函数是被windows调用出来的指向windows。| 0</span></span><br><span class="line"><span class="keyword">new</span> test();<span class="comment">//0 |undefined:构造函数中的this是指向实例的 |0</span></span><br></pre></td></tr></table></figure>
<h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo.f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo.prototype.f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">&#125;<span class="comment">// 变量声明会“被提前”了，但是他的赋值，并不会被提前。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'5'</span>);<span class="comment">//函数声明和赋值都会被提前到作用域的顶部</span></span><br><span class="line">&#125;<span class="comment">//函数声明提升</span></span><br><span class="line"><span class="comment">//写出下面的结果</span></span><br><span class="line">foo.f();<span class="comment">//2执行了foo对象的f()方法</span></span><br><span class="line">f();<span class="comment">// 4 声明前置</span></span><br><span class="line"></span><br><span class="line">foo().f();<span class="comment">//1 foo()是函数的调用，foo()对f进行了重新赋值,return this是window，在window中找f(),此时f()别重新赋值了。</span></span><br><span class="line"><span class="keyword">new</span> foo.f();<span class="comment">//2  一个foo.f的实例</span></span><br><span class="line"><span class="keyword">new</span> foo().f();<span class="comment">//3 (new foo()).f() 一个foo的实例，接着执行Foo的实例上的 f函数，那么 先从实例上查找f函数，发现找不到（Foo上有一个静态的bar函数，但是不是实例的方法，只能通过构造函数调用），然后接着从原型链上查找到f方法，调用。</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> foo().f();<span class="comment">//3 new new foo().f() 创建foo实例，创建foo.f(=foo.prototype.f)实例</span></span><br></pre></td></tr></table></figure>
<p>使用关键字new创建新实例对象经过了以下几步：  </p>
</li>
<li><p>创建一个新对象</p>
</li>
<li><p>将新对象的_proto_指向构造函数的prototype对象</p>
</li>
<li><p>将构造函数的作用域赋值给新对象 （也就是this指向新对象）</p>
</li>
<li><p>执行构造函数中的代码（为这个新对象添加属性）</p>
</li>
<li><p>返回新的对象</p>
</li>
</ol>
<!--  #### Foo().getName()

输出结果为：1
原理：Foo()是函数调用，Foo执行体中对getName进行了重新赋值（全局的getName，根据作用域链向上查找），返回的this为window(Foo执行时没有调用，默认为全局)，然后.getName()调用了全局的getName（也就是被Foo执行体重写的getName），所以结果为:1
#### getName()

输出结果为：1 原理：因为Foo执行体中对全局getName重写了，这时调用的又是全局的getName。所以结果为:1 -->
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/16/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YOLO">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/16/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-16T16:05:43+08:00">
                2020-10-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/10/06/cssSelector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YOLO">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/06/cssSelector/" itemprop="url">cssSelector</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-06T21:31:52+08:00">
                2020-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p>选择器是用来在树中匹配元素的模式，是用来选择XML文档中节点的几种技术之一。选择器对HTML和XML进行了优化，被设计用来在注重性能的代码中执行。</p>
<p>CSS是一个被用来描述如何在屏幕等处渲染HTML和XML文档的语言。CSS使用选择器来为文档中的元素绑定样式属性（style properties）。</p>
<p>这篇文档描述了已经在CSS1和CSS2中出现，以及之后将在CSS3中新出现的选择器，在其他语言中也可能用到它们。</p>
<h2 id="选择器语法"><a href="#选择器语法" class="headerlink" title="选择器语法"></a>选择器语法</h2><p>一个选择器由是一个或多个被组合器隔开的 简单选择器序列 组成的链条。一个伪元素可能被添加到最后的简单选择器序列之后。<br>组合器是：空白符，大于号 (U+003E, &gt;), 加号 (U+002B, +) 和 波浪符 (U+007E, ~)。空白符可能出现在组合器和简单选择器之间。只有空格 (U+0020), tab (U+0009), 换行符 (U+000A), 回车符 (U+000D), 和 换页符 (U+000C)可以出现在空白符中。任何其他的类似空格的字符，例如”em-space” (U+2003) 和 “ideographic space” (U+3000)不属于空白符。</p>
<h4 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h4><p>类型选择器允许添加一个可选择的命名空间：元素名称开头可能被添加一个已经被预先定义的命名空间名作为前缀，被命名空间分隔符 竖线(U+007C, |)分割。</p>
<p>命名空间组件可能左边是空的（在命名空间分隔符前没有前缀）来表明选择器仅仅作用于没有命名空间的元素。</p>
<p>一个星号可能被用于命名空间前缀，表明这个选择器作用于任何命名空间的元素（包括没有命名空间的元素）。</p>
<p>元素类型选择器没有命名空间组件（没有命名空间分隔符）表示忽略命名空间（等价于*|），除非一个默认命名空间被声明。如果一个默认命名空间被声明，前面的选择器仅仅作用于默认命名空间下的元素。</p>
<p>如果一个类型选择器包含没有预先定义的命名空间前缀,将是一个无效选择器。<br>在支持命名空间的客户端中，元素类型选择器的名称部分仅仅和本地元素限定名竞争。</p>
<ul>
<li><p>ns|E 命名空间ns中的名称为E的元素。</p>
</li>
<li><p>*|E 任何命名空间中名称为E的元素，包含没有命名空间的元素。</p>
</li>
<li><p>|E 没有命名空间的名称为E的元素。</p>
</li>
<li><p>E 如果没有默认命名空间，等价于*|E。否则等价于ns|E，ns是默认命名空间。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">namespace</span> foo url(http://www.example.com);</span><br><span class="line"> foo|h1 &#123; color: blue &#125;  /* 第一条规则 */</span><br><span class="line"> foo|* &#123; color: yellow &#125; /* 第二条规则 */</span><br><span class="line"> |h1 &#123; color: red &#125;      /* ...*/</span><br><span class="line"> *|h1 &#123; color: green &#125;</span><br><span class="line"> <span class="selector-tag">h1</span> &#123; <span class="attribute">color</span>: green &#125;</span><br><span class="line"></span><br><span class="line">第一条规则（不包括@namespace这行）将会仅仅匹配"http://www.example.com" 命名空间下的h1元素。</span><br><span class="line"></span><br><span class="line">第二条规则将会匹配命名空间 "http://www.example.com" 下的所有元素。</span><br><span class="line"></span><br><span class="line">第三条规则将会匹配没有命名空间中的<span class="selector-tag">h1</span>元素。</span><br><span class="line"></span><br><span class="line">第四条规则将会匹配任何命名空间中的<span class="selector-tag">h1</span>元素（包括没有命名空间的<span class="selector-tag">h1</span>元素）。</span><br><span class="line"></span><br><span class="line">最后一条等同于第四条，因为没有默认命名空间被定义。</span><br></pre></td></tr></table></figure>
<h2 id="类选择器和ID选择器"><a href="#类选择器和ID选择器" class="headerlink" title="类选择器和ID选择器"></a>类选择器和ID选择器</h2><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.warning</span>&#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br></pre></td></tr></table></figure>
<p>意思是font-weight:bold;样式会应用到class属性为warning的所有元素上<br>可以看到，类选择器要正常工作，需要直接引用一个元素的class属性中的值。这个引用前往往只有一个(.),标记这是一个类选择器。通过这个点号，可以帮助类选择器与它可能结合的其他部分个开。例如 只希望整个段落是warning时才显示粗体</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-class">.warning</span>&#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="多类选择器"><a href="#多类选择器" class="headerlink" title="多类选择器"></a>多类选择器</h3><p>一个class可能包含一个词列表，各个词在之间用空格分开<br>class=”urgent warning”</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.urgent</span><span class="selector-class">.warning</span>&#123;<span class="attribute">font-weight</span>:bold;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><p>ID选择器前面有一个#号</p>
<h3 id="选择？"><a href="#选择？" class="headerlink" title="选择？"></a>选择？</h3><p>可以为任意多个元素指定类；与此不同，在一个HTML文档中，ID选择器会使用一次，而且仅一次。因此，如果有一个与元素的id值为lead-para，那么该文档中所有其他元素的id值都不能是lead-para。<br>id选择器不能结合使用，因为id属性不允许有以空格分隔的词列表。  </p>
<h3 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h3><p>前面使用的语法是HTML、SVG、MathML文档特定的。写其他标记语言中，不能使用这些类和ID选择器。为解决这个问题，css2中引入了属性选择器。它可以根据元素的属性及属性值。共有四类属性选择器。</p>
<h4 id="简单属性选择器"><a href="#简单属性选择器" class="headerlink" title="简单属性选择器"></a>简单属性选择器</h4><p>例如 要选择有class属性的所有h1元素，使其文本为银色</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h1&#123;class&#125;&#123;color:silver;&#125;</span><br></pre></td></tr></table></figure>
<p>这个策略在XML中相当有用，因为XML语言主张要针对元素和属性的用途指定元素名和属性名。<br>如果你想把包含标题（title）信息的所有元素变为粗体显示（光标停留在这些元素上时大多数浏览器都会将其显示为)<br>就可以写作</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*<span class="selector-attr">[title]</span> &#123;<span class="attribute">font-weigh</span>:bold;&#125;</span><br></pre></td></tr></table></figure>
<p>还可以进行多个属性的选择，只需要将属性链接在一起即可。<br>例：为了同时将有href和title属性的html超链接的文本设置为粗体，可以写作：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span><span class="selector-attr">[title]</span> &#123;<span class="attribute">font-weigh</span>:bold;&#125;</span><br></pre></td></tr></table></figure>
<p>这将会使以下标记的第一个链接变为粗体，第二个第三个不会</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="http://" title="w3school"&gt;</span><br><span class="line">&lt;a href="https://"&gt;</span><br><span class="line">&lt;a title="w3school"&gt;</span><br></pre></td></tr></table></figure>
<h4 id="根据具体的属性值"><a href="#根据具体的属性值" class="headerlink" title="根据具体的属性值"></a>根据具体的属性值</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href="http://"]</span>&#123;<span class="attribute">font-weigh</span>: bold;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="根据部分属性值选择"><a href="#根据部分属性值选择" class="headerlink" title="根据部分属性值选择"></a>根据部分属性值选择</h4><p>如果属性能够接受词列表，可以根据其中任意一个词进行选择。在HTML中，这方面最经典的例子就是class属性，它能接受一个或者多个词为其属性值。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;p class="urgent warning"&gt;when handling plutonum, care must be taken to avoid the formation of a critical mass.&lt;/p&gt;</span><br></pre></td></tr></table></figure>
<p>如果想选择class属性中包含warning元素可以用属性选择器</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span><span class="selector-attr">[class~="warning"]</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>部分选择的关键（～）</p>
<h4 id="子串匹配属性选择器"><a href="#子串匹配属性选择器" class="headerlink" title="子串匹配属性选择器"></a>子串匹配属性选择器</h4><p>[foo^=”bar”]选择foo属性值以”bar”开头的所有元素<br>[foo$=]结尾</p>
</li>
<li><p>=</p>
<h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p>根据父子关系选择元素，不仅限于两个元素</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">ol</span> <span class="selector-tag">ul</span> <span class="selector-tag">em</span> &#123;<span class="attribute">color</span>:gray;&#125;</span><br></pre></td></tr></table></figure>
<p>无序列表的有序列表一个无序列表强调文本为灰色</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/02/js111/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YOLO">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/02/js111/" itemprop="url">js111</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-02T13:14:43+08:00">
                2020-08-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JS最新基本数据类型-BigInt"><a href="#JS最新基本数据类型-BigInt" class="headerlink" title="JS最新基本数据类型:BigInt"></a>JS最新基本数据类型:BigInt</h2><p>BigInt数据类型的目的是比Number数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用BigInt，整数溢出将不再是问题。</p>
<p>此外，可以安全地使用更加准确时间戳，大整数ID等，而无需使用变通方法。 BigInt目前是第3阶段提案， 一旦添加到规范中，它就是JS 第二个数字数据类型，也将是 JS 第8种基本数据类型：<br>对于学过其他语言的程序员来说，JS中缺少显式整数类型常常令人困惑。许多编程语言支持多种数字类型，如浮点型、双精度型、整数型和双精度型，但JS却不是这样。在JS中，按照IEEE 754-2008标准的定义，所有数字都以双精度64位浮点格式表示。</p>
<p>在此标准下，无法精确表示的非常大的整数将自动四舍五入。确切地说，JS 中的Number类型只能安全地表示-9007199254740991 (-(2^53-1)) 和9007199254740991(2^53-1)之间的整数，任何超出此范围的整数值都可能失去精度。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">coonsole.log(<span class="number">9999999999999999</span>);    <span class="comment">// → 10000000000000000)</span></span><br><span class="line">该整数大于JS <span class="built_in">Number</span> 类型所能表示的最大整数，因此，它被四舍五入的。意外四舍五入会损害程序的可靠性和安全性。这是另一个例子：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意最后一位的数字</span></span><br><span class="line"><span class="number">9007199254740992</span> === <span class="number">9007199254740993</span>;    <span class="comment">// → true</span></span><br></pre></td></tr></table></figure>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>为了解决这些限制，一些JS开发人员使用字符串类型表示大整数。 例如，Twitter API 在使用 JSON 进行响应时会向对象添加字符串版本的 ID。 此外，还开发了许多库，例如 bignumber.js，以便更容易地处理大整数。</p>
<p>使用BigInt，应用程序不再需要变通方法或库来安全地表示Number.MAX_SAFE_INTEGER和Number.Min_SAFE_INTEGER之外的整数。 现在可以在标准JS中执行对大整数的算术运算，而不会有精度损失的风险。</p>
<p>要创建BigInt，只需在整数的末尾追加n即可。比较:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">9007199254740995n</span>);    <span class="comment">// → 9007199254740995n</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">9007199254740995</span>);     <span class="comment">// → 9007199254740996</span></span><br></pre></td></tr></table></figure>
<p>或者，可以调用BigInt()构造函数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BigInt(<span class="string">"9007199254740995"</span>);    <span class="comment">// → 9007199254740995n</span></span><br><span class="line">BigInt文字也可以用二进制、八进制或十六进制表示</span><br><span class="line"></span><br><span class="line"><span class="comment">// binary</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0b100000000000000000000000000000000000000000000000000011n</span>);</span><br><span class="line"><span class="comment">// → 9007199254740995n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hex</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0x20000000000003n</span>);</span><br><span class="line"><span class="comment">// → 9007199254740995n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// octal</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0o400000000000000003n</span>);</span><br><span class="line"><span class="comment">// → 9007199254740995n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// note that legacy octal syntax is not supported</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0400000000000000003n</span>);</span><br><span class="line"><span class="comment">// → SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>请记住，不能使用严格相等运算符将BigInt与常规数字进行比较，因为它们的类型不同：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">10n</span> === <span class="number">10</span>);    <span class="comment">// → false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">10n</span>);    <span class="comment">// → bigint</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">10</span>);     <span class="comment">// → number</span></span><br></pre></td></tr></table></figure>
<p>相反，可以使用等号运算符，它在处理操作数之前执行隐式类型转换</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">10n</span> == <span class="number">10</span>);    <span class="comment">// → true</span></span><br></pre></td></tr></table></figure>
<p>除一元加号(+)运算符外，所有算术运算符都可用于BigInt</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10n</span> + <span class="number">20n</span>;    <span class="comment">// → 30n</span></span><br><span class="line"><span class="number">10n</span> - <span class="number">20n</span>;    <span class="comment">// → -10n</span></span><br><span class="line">+<span class="number">10n</span>;         <span class="comment">// → TypeError: Cannot convert a BigInt value to a number</span></span><br><span class="line"><span class="number">-10n</span>;         <span class="comment">// → -10n</span></span><br><span class="line"><span class="number">10n</span> * <span class="number">20n</span>;    <span class="comment">// → 200n</span></span><br><span class="line"><span class="number">20n</span> / <span class="number">10n</span>;    <span class="comment">// → 2n</span></span><br><span class="line"><span class="number">23n</span> % <span class="number">10n</span>;    <span class="comment">// → 3n</span></span><br><span class="line"><span class="number">10n</span> ** <span class="number">3n</span>;    <span class="comment">// → 1000n</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">10n</span>;</span><br><span class="line">++x;          <span class="comment">// → 11n</span></span><br><span class="line">--x;          <span class="comment">// → 9n</span></span><br></pre></td></tr></table></figure>
<p>不支持一元加号（+）运算符的原因是某些程序可能依赖于+始终生成Number的不变量，或者抛出异常。 更改+的行为也会破坏asm.js代码。</p>
<p>当然，与BigInt操作数一起使用时，算术运算符应该返回BigInt值。因此，除法(/)运算符的结果会自动向下舍入到最接近的整数。例如:</p>
<p>25 / 10;      // → 2.5<br>25n / 10n;    // → 2n</p>
<h3 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h3><p>因为隐式类型转换可能丢失信息，所以不允许在bigint和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。思考下面的例子：</p>
<p>(9007199254740992n + 1n) + 0.5<br>这个表达式的结果超出了BigInt和Number的范围。小数部分的Number不能精确地转换为BigInt。大于2^53的BigInt不能准确地转换为数字。</p>
<p>由于这个限制，不可能对混合使用Number和BigInt操作数执行算术操作。还不能将BigInt传递给Web api和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="number">10n</span>;    <span class="comment">// → TypeError</span></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">2n</span>, <span class="number">4n</span>, <span class="number">6n</span>);    <span class="comment">// → TypeError</span></span><br></pre></td></tr></table></figure>
<p>请注意，关系运算符不遵循此规则，如下例所示：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10n</span> &gt; <span class="number">5</span>;    <span class="comment">// → true</span></span><br></pre></td></tr></table></figure>
<p>如果希望使用BigInt和Number执行算术计算，首先需要确定应该在哪个类型中执行该操作。为此，只需通过调用Number()或BigInt()来转换操作数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInt(<span class="number">10</span>) + <span class="number">10n</span>;    <span class="comment">// → 20n</span></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"><span class="number">10</span> + <span class="built_in">Number</span>(<span class="number">10n</span>);    <span class="comment">// → 20</span></span><br></pre></td></tr></table></figure>
<p>当 Boolean 类型与BigInt 类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">5n</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里代码块将被执行</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">0n</span>) &#123;</span><br><span class="line">    <span class="comment">// 这里代码块不会执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>排序BigInts和Numbers数组时，不会发生隐式类型转换：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">3n</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1n</span>, <span class="number">0</span>, <span class="number">-1n</span>];</span><br><span class="line"></span><br><span class="line">arr.sort();    <span class="comment">// → [-1n, 0, 1n, 2, 3n, 4]</span></span><br><span class="line">位操作符如|、&amp;、&lt;&lt;、&gt;&gt;和^对Bigint的操作方式与<span class="built_in">Number</span>类似。下面是一些例子</span><br><span class="line"></span><br><span class="line"><span class="number">90</span> | <span class="number">115</span>;      <span class="comment">// → 123</span></span><br><span class="line"><span class="number">90n</span> | <span class="number">115n</span>;    <span class="comment">// → 123n</span></span><br><span class="line"><span class="number">90n</span> | <span class="number">115</span>;     <span class="comment">// → TypeError</span></span><br></pre></td></tr></table></figure>
<p>BigInt构造函数<br>与其他基本类型一样，可以使用构造函数创建BigInt。传递给BigInt()的参数将自动转换为BigInt:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInt(<span class="string">"10"</span>);    <span class="comment">// → 10n</span></span><br><span class="line">BigInt(<span class="number">10</span>);      <span class="comment">// → 10n</span></span><br><span class="line">BigInt(<span class="literal">true</span>);    <span class="comment">// → 1n</span></span><br></pre></td></tr></table></figure>
<p>无法转换的数据类型和值会引发异常:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInt(<span class="number">10.2</span>);     <span class="comment">// → RangeError</span></span><br><span class="line">BigInt(<span class="literal">null</span>);     <span class="comment">// → TypeError</span></span><br><span class="line">BigInt(<span class="string">"abc"</span>);    <span class="comment">// → SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>可以直接对使用构造函数创建的BigInt执行算术操作</p>
<p>BigInt(10) * 10n;    // → 100n</p>
<p>使用严格相等运算符的操作数时，使用构造函数创建的Bigint与常规Bigint的处理方式类似</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BigInt(<span class="literal">true</span>) === <span class="number">1n</span>;    <span class="comment">// → true</span></span><br></pre></td></tr></table></figure>
<p>库函数<br>在撰写本文时，Chrome +67 和Opera +54完全支持BigInt数据类型。不幸的是，Edge和Safari还没有实现它。Firefox默认不支持BigInt，但是可以在about:config中将javascript.options.bigint 设置为true来开启它，最新支持的情况可在“Can I use”上查看。</p>
<p>不幸的是，转换BigInt是一个极其复杂的过程，这会导致严重的运行时性能损失。直接polyfill BigInt也是不可能的，因为该提议改变了几个现有操作符的行为。目前，更好的选择是使用JSBI库，它是BigInt提案的纯JS实现。</p>
<p>这个库提供了一个与原生BigInt行为完全相同的API。下面是如何使用JSBI：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> JSBI <span class="keyword">from</span> <span class="string">'./jsbi.mjs'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b1 = JSBI.BigInt(<span class="built_in">Number</span>.MAX_SAFE_INTEGER);</span><br><span class="line"><span class="keyword">const</span> b2 = JSBI.BigInt(<span class="string">'10'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = JSBI.add(b1, b2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(result));    <span class="comment">// → '9007199254741001'</span></span><br></pre></td></tr></table></figure>
<p>使用JSBI的一个优点是，一旦浏览器支持，就不需要重写代码。 相反，可以使用babel插件自动将JSBI代码编译为原生 BigInt代码。</p>
<p>总结<br>BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。</p>
<p>重要的是要记住，不能使用Number和BigInt操作数的混合执行算术运算，需要通过显式转换其中的一种类型。 此外，出于兼容性原因，不允许在BigInt上使用一元加号（+）运算符。<br>来源：<a href="https://segmentfault.com/a/1190000019912017" target="_blank" rel="noopener">https://segmentfault.com/a/1190000019912017</a></p>
<h2 id="for-in-与-Object-keys-与-hasOwnProperty区别"><a href="#for-in-与-Object-keys-与-hasOwnProperty区别" class="headerlink" title="for in 与 Object.keys 与 hasOwnProperty区别"></a>for in 与 Object.keys 与 hasOwnProperty区别</h2><p>1、结论</p>
<p>for in遍历对象所有可枚举属性 包括原型链上的属性</p>
<p>Object.keys遍历对象所有可枚举属性 不包括原型链上的属性</p>
<p>hasOwnProperty 检查对象是否包含属性名，无法检查原型链上是否具有此属性名</p>
<p>1.在某个对象是否拥有某个属性，判断的方法有很多，常用的方法就是object.hasOwnProperty(‘×××’)，这个方法是不包括对象原型链上的方法的，举个例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    name:<span class="string">'fei'</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'name'</span>))<span class="comment">//true</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj.hasOwnProperty(<span class="string">'toString'</span>))<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，obj对象存在的name属性的时候，调用这个方法才是返回true，我们知道其实每个对象实例的原型链上存在toString方法，在这里打印false，说明这个方法只是表明实例对象的属性，不包括原型链上的属性。</p>
<p>　2.下面我们再来看看in的使用，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">     name:<span class="string">'fei'</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'toString'</span> <span class="keyword">in</span> obj)<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，其实在这个例子中，我只是给了对象一个属性name，并没有其他的属性，然后我执行’tiString’ in obj，可以看出控制动态打印出来的是true，原因就是对象的原型链上存在toString方法，所以in操作不管是不是原型链上，只要存在这个属性，返回的就是true。<br>3.接着我们再看for in。在使用for in 循环的时候，其实返回的是能通过对象访问的，可枚举的，包括实例中的，也包括原型中的，例子如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">      name:<span class="string">'fei'</span>,</span><br><span class="line">      age:<span class="number">20</span>,</span><br><span class="line">      friend:[<span class="string">"fei"</span>,<span class="string">"jun"</span>,<span class="string">"zhu"</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i)<span class="comment">//会打印三次，name，age，friend</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么上面没有打印原型中的属性呢，因为原型中的属性都默认设置了不可枚举（enumerated）；我们将例子改成下面这样：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">      name:<span class="string">'fei'</span>,</span><br><span class="line">      age:<span class="number">20</span>,</span><br><span class="line">      friend:[<span class="string">"fei"</span>,<span class="string">"jun"</span>,<span class="string">"zhu"</span>]</span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">Object</span>.defineProperty(obj, <span class="string">'like'</span>, &#123;<span class="comment">//使用Object.defineProperty()方法可以设置你设置属性的特性</span></span><br><span class="line">      enumerable:<span class="literal">false</span>,<span class="comment">//设置不可枚举</span></span><br><span class="line">      value:<span class="string">'basketball'</span><span class="comment">//值为basketball</span></span><br><span class="line"> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(obj)<span class="comment">//Object &#123;name: "fei", age: 20, friend: Array[3], like: "basketball"&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(i)<span class="comment">//依旧打印三个name,age,friend</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个例子中可以看出，在给属性设置为不可枚举的时候，是不会出现在for in循环中的，这也造成IE低版本出现bug，就是不可枚举的属性不会出现在for in中，如果你从新定义了一个属性和原型的属性相同，那么这个属性也不会出现在for in中，现在的浏览器不会出现，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">        toString:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="string">"666"</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> obj)&#123;</span><br><span class="line">       <span class="keyword">if</span>(i==<span class="string">"toString"</span>)&#123;</span><br><span class="line">              <span class="built_in">console</span>.log(<span class="string">'我出现了'</span>) <span class="comment">//在低版本的IE中不显示</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>4.要取得所有可枚举的对象，可以使用ECMAscript5的方法Object.keys(),接受一个对象为参数，返回所有可枚举的属性的字符串数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">People.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'say'</span>)</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.name = <span class="string">"feifei"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> people = <span class="keyword">new</span> People()</span><br><span class="line">people.age = <span class="number">12</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(people))<span class="comment">//['age']</span></span><br></pre></td></tr></table></figure>
<p>这个方法并不会包含原型链中的属性，只是实例中的可枚举的属性。</p>
<p>5.获取实例中所有属性，无论是否可枚举，利用Object.getOwnPropertyNames(),以对象为参数，返回熟悉的数组。例子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line">People.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'say'</span>)</span><br><span class="line">&#125;</span><br><span class="line">People.prototype.name = <span class="string">"feifei"</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> people = <span class="keyword">new</span> People()</span><br><span class="line">people.age = <span class="number">12</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(people, <span class="string">'like'</span>, &#123;<span class="comment">//使用Object.defineProperty()方法可以设置你设置属性的特性</span></span><br><span class="line">      enumerable:<span class="literal">false</span>,<span class="comment">//设置不可枚举</span></span><br><span class="line">      value:<span class="string">'basketball'</span><span class="comment">//值为basketball</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(people)<span class="comment">//People &#123;age: 12, like: "basketball"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(people))<span class="comment">//["age", "like"]</span></span><br></pre></td></tr></table></figure>
<p>这个方法仅仅是返回实例中所有的属性，无论是不是可枚举的，不包括原型里面的属性。<br>3、ESLINT对for in的限制</p>
<p>当你在某个对象上用 for in 语句遍历对象属性，而又忘了用 hasOwnProperty 判断属性来源的时候，你就会发现被你扩展的原型属性也会被遍历出来，这往往都不是我们想要的结果。</p>
<p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for…in循环，而用Object.keys()代替。</p>
<p>ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for…of循环使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = <span class="built_in">Object</span>;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key); <span class="comment">// 'a', 'b', 'c'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> value <span class="keyword">of</span> values(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1, 2, 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log([key, value]); <span class="comment">// ['a', 1], ['b', 2], ['c', 3]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来源：<a href="https://www.cnblogs.com/zhenfei-jiang/p/7028686.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhenfei-jiang/p/7028686.html</a><br><a href="https://www.cnblogs.com/xbcq/p/5649575" target="_blank" rel="noopener">https://www.cnblogs.com/xbcq/p/5649575</a>.</p>
<h2 id="将字符串变成数组的方法"><a href="#将字符串变成数组的方法" class="headerlink" title="将字符串变成数组的方法"></a>将字符串变成数组的方法</h2><h4 id="一）、es5的方法"><a href="#一）、es5的方法" class="headerlink" title="一）、es5的方法"></a>一）、es5的方法</h4><p>1、split()<br>用指定的分隔符把一个字符串分割存储到数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 =s.split(<span class="string">""</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"方法2："</span>,arr2);</span><br><span class="line"><span class="comment">// [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ]</span></span><br></pre></td></tr></table></figure>
<p>2、slice()<br>从当前数组中截取一个子数组并且返回</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//因为slice是数组中的方法，所以要用call使this指向s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr5 = <span class="built_in">Array</span>.prototype.slice.call(s);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"方法5："</span>,arr5);</span><br><span class="line"><span class="comment">// [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ]</span></span><br></pre></td></tr></table></figure>

<h3 id="二）、es6的方法"><a href="#二）、es6的方法" class="headerlink" title="二）、es6的方法"></a>二）、es6的方法</h3><p>3、rest<br>…obj 将对象中成员剥离出来</p>
<p>let s =”hello world”;</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里的用法是先将字符串的每一个字符剥离出来，再存放到数组里</span></span><br><span class="line"><span class="keyword">let</span> arr =[...s]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"方法1："</span>,arr);</span><br><span class="line"><span class="comment">// [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ]</span></span><br></pre></td></tr></table></figure>
<p>4、Object.values()<br>这个方法是返回一个数组，数组成员是原先对象的所有属性值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = <span class="built_in">Object</span>.values(s);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"方法3："</span>,arr3);</span><br><span class="line"><span class="comment">// [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ]</span></span><br></pre></td></tr></table></figure>
<p>5、Array.from()<br>将类数组对象或者可遍历的对象转为真正数组</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr4 = <span class="built_in">Array</span>.from(s);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"方法4："</span>,arr4);</span><br><span class="line"><span class="comment">// [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ]</span></span><br></pre></td></tr></table></figure>
<p>原文链接：<a href="https://blog.csdn.net/hxrykl/java/article/details/102497596" target="_blank" rel="noopener">https://blog.csdn.net/hxrykl/java/article/details/102497596</a></p>
<h2 id="js中-和-和-的区别"><a href="#js中-和-和-的区别" class="headerlink" title="js中[]和{}和()的区别"></a>js中[]和{}和()的区别</h2><h3 id="一、-大括号，表示定义一个对象，大部分情况下要有成对的属性和值，或是函数体"><a href="#一、-大括号，表示定义一个对象，大部分情况下要有成对的属性和值，或是函数体" class="headerlink" title="一、{ } 大括号，表示定义一个对象，大部分情况下要有成对的属性和值，或是函数体"></a>一、{ } 大括号，表示定义一个对象，大部分情况下要有成对的属性和值，或是函数体</h3><p>{}表示对象、[]表示对象的属性、方法,()如果用在方法名后面，代表调用<br>如：var LangShen = {“Name”:”Langshen”,”AGE”:”28”};<br>上面声明了一个名为“LangShen”的对象，多个属性或函数用,（逗号）隔开，因为是对象的属性，<br>所以访问时，应该用.（点）来层层访问：LangShen.Name、LangShen.AGE，<br>当然我们也可以用数组的方式来访问，如：LangShen[“Name”]、LangShen[“AGE”]，结果是一样的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LangShen = &#123; </span><br><span class="line">    Name : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"LangShen"</span>; </span><br><span class="line">    &#125;, </span><br><span class="line">    Age : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"28"</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line">调用 LangShen.Name()</span><br></pre></td></tr></table></figure>
<h3 id="二、-中括号，表示一个数组，也可以理解为一个数组对象"><a href="#二、-中括号，表示一个数组，也可以理解为一个数组对象" class="headerlink" title="二、[ ]中括号，表示一个数组，也可以理解为一个数组对象"></a>二、[ ]中括号，表示一个数组，也可以理解为一个数组对象</h3><p>如：var LangShen = [ “Name”,”LangShen”,”AGE”,”28” ];<br>很明显，每个值或函数，都是独立的，多个值之间只用,（逗号）隔开，因为是数组对象，所以它等于：<br>var LangShen = Array( “Name”,”LangShen”,”AGE”,”28” );<br>访问时，也是和数组一样，alert( LangShen[0] )</p>
<h3 id="三、-和-一起使用，我们前面说到，-是一个对象，-是一个数组，我们可以组成一个对象数组"><a href="#三、-和-一起使用，我们前面说到，-是一个对象，-是一个数组，我们可以组成一个对象数组" class="headerlink" title="三、{ } 和[ ] 一起使用，我们前面说到，{ } 是一个对象，[ ] 是一个数组，我们可以组成一个对象数组"></a>三、{ } 和[ ] 一起使用，我们前面说到，{ } 是一个对象，[ ] 是一个数组，我们可以组成一个对象数组</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> LangShen = &#123; </span><br><span class="line">    <span class="string">"Name"</span>:<span class="string">"Langshen"</span>, </span><br><span class="line">    <span class="string">"MyWife"</span>:[ <span class="string">"LuLu"</span>,<span class="string">"26"</span> ], </span><br><span class="line">    <span class="string">"MySon"</span>:[&#123;<span class="string">"Name"</span>:<span class="string">"Son1"</span>&#125;,&#123;<span class="string">"Name"</span>:<span class="string">"Son2"</span>&#125;,&#123;<span class="string">"Name"</span>:<span class="string">"Son3"</span>&#125;] </span><br><span class="line">&#125; </span><br><span class="line">从上面的结构来看，是一个对象里面的第一项是个属性，第二项是一个数组，第三个是包含有多个对象的数组。</span><br><span class="line">调用起来，也是一层一层访问，对象的属性用.（点）叠加，数组用 [下标] 来访问。 </span><br><span class="line">如：alert( LangShen.MySon[<span class="number">1</span>].Name ) ；</span><br><span class="line"><span class="keyword">var</span> LangShen=[</span><br><span class="line">    &#123;“name”：“wangwu”&#125;,</span><br><span class="line">    &#123;“name”：“lieu”&#125;</span><br><span class="line">];</span><br><span class="line">这是一个对象数组</span><br></pre></td></tr></table></figure>
<h3 id="四、-多表示参数、-表示函数体-要看它放在什么位置才能知道它起什么作用，因为它有多种用法"><a href="#四、-多表示参数、-表示函数体-要看它放在什么位置才能知道它起什么作用，因为它有多种用法" class="headerlink" title="四、()多表示参数、{}表示函数体  ()要看它放在什么位置才能知道它起什么作用，因为它有多种用法"></a>四、()多表示参数、{}表示函数体  ()要看它放在什么位置才能知道它起什么作用，因为它有多种用法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">    Alert(name);</span><br><span class="line">&#125;</span><br><span class="line">es6中，</span><br><span class="line"><span class="keyword">let</span> show=<span class="function">(<span class="params">name</span>)=&gt;</span>&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">&#125;</span><br><span class="line">在es6中如果参数只有一个，或者函数体只有一个话，可以省略（）、&#123;&#125;,如</span><br><span class="line"><span class="keyword">let</span> show=<span class="function"><span class="params">name</span>=&gt;</span>alert(name);</span><br></pre></td></tr></table></figure>
<p>来源：<a href="https://www.cnblogs.com/mike-mei/p/11194138.html" target="_blank" rel="noopener">https://www.cnblogs.com/mike-mei/p/11194138.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/10/%E5%BC%82%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YOLO">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/10/%E5%BC%82%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/" itemprop="url">异常和错误处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-10T01:42:26+08:00">
                2020-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="异常和错误处理"><a href="#异常和错误处理" class="headerlink" title="异常和错误处理"></a>异常和错误处理</h2><p>异常处理 是一种可控的方式处理错误的机制。 <strong>并非处理预期的错误，而是预期之外的错误。</strong><br>例子：无效的邮件地址（预期的错误）  磁盘空间不足，服务不可用（预期之外的错误）</p>
<h3 id="1-Error对象和try…catch"><a href="#1-Error对象和try…catch" class="headerlink" title="1 Error对象和try…catch"></a>1 Error对象和try…catch</h3><p>可以用来处理任意类型的错误（异常或预期错误）。<br>执行代码期间可能会发生的错误有多种类型。每种错误都有对应的错误类型，而当错误发生时，就 会抛出相应类型的错误对象。js共定义了下列 7 种错误类型：</p>
<ul>
<li>Error ‰</li>
<li>EvalError</li>
<li>RangeError ‰</li>
<li>ReferenceError ‰</li>
<li>SyntaxError ‰</li>
<li>TypeError ‰</li>
<li>URIError<br>Error类型是基本的错误类型，其他类型都继承自这个类型。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line">  someFunction(); </span><br><span class="line">&#125; <span class="keyword">catch</span> (error)&#123; </span><br><span class="line">  <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="built_in">TypeError</span>)&#123; </span><br><span class="line">    <span class="comment">//处理ૌ类型错误 </span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error <span class="keyword">instanceof</span> <span class="built_in">ReferenceError</span>)&#123; </span><br><span class="line">    <span class="comment">//处理引用错误 </span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">      <span class="comment">//处理其他的错误 </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
把有可能出的问题的代码放在 try 语句中。try语句中可以理论上可以写任何的代码，只要有一行代码出现问题，整个程序的执行流程就会立即调到catch语句中执行。<br>一旦try中有一行代码发生异常，则这行出错代码的后面的try中的其他语句都不会再执行。   </li>
</ul>
<p>在执行catch中的代码之前，js引擎会首先根据错误类型自动创建一个错误，并通过catch后面的参数传递到catch中。不同的浏览器创建的error对象不一样，但是同创他们都包含一个message属性，值是这个错误的一些信息。<br>catch中的代码执行完毕之后，会继续执行后面的代码，程序不会停止下来。</p>
<h5 id="合理使用try……catch"><a href="#合理使用try……catch" class="headerlink" title="合理使用try……catch"></a>合理使用try……catch</h5><p>​ 当 try-catch 语句中发生错误时，浏览器会认为错误已经被处理了，浏览器就不再报告错误了。这也是最简单的一种情况。</p>
<p>​ 使用 try-catch 最适合处理那些我们无法控制的错误。假设你在使用一个大型 JavaScript 库中的 函数，该函数可能会有意无意地抛出一些错误。由于我们不能修改这个库的源代码，所以大可将对该函 数的调用放在 try-catch 语句当中，一有什么错误发生，也好可以恰当地处理它们。</p>
<p>​ 在明明知道自己的代码会发生错误时，再使用 try-catch 语句就不太合适了。例如，如果 传给函数的参数是字符串而非数值，就会造成函数出错，那么就应该先检查参数的类型，然后再决定 如何去做。在这种情况下，不应用使用 try-catch 语句。因为try…catch语句比较是比较好资源的事情</p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>很多时候，try块中包含一些对资源的引用，不管有没有发生错误，都需要释放这些资源，防止应用程序永远占用着资源，由于try块中可与包含很多语句，任何一条都有可能发生错误，所以在try块里释放资源并不安全（因为错误可能发生在释放资源之前，这样就没有机会释放资源了）。同样在catch中释放资源也不安全，因为catch中的代码只有在发生错误的时候才会执行。这时finally就派上用场了，不管是否发生错误，finally中的代码都会被执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"this line is executed...."</span>);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"whoops"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"this line is not..."</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(err)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"there was an error..."</span>);</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"...always executed"</span>);</span><br><span class="line">     <span class="built_in">console</span>.log(<span class="string">"perform cleanup here"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主动抛出异常"><a href="#主动抛出异常" class="headerlink" title="主动抛出异常"></a>主动抛出异常</h3><p>在大部分的代码执行过程中，都是出现错误的时候，由浏览器(javascript引擎)抛出异常，然后程序或者停止执行，或被try…catch 捕获。</p>
<p>​ 然而有时候我们在检测到一些不合理的情况发生的时候也可以主动抛出错误。</p>
<p>​ 使用 throw 关键字抛出来主动抛出异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> num == <span class="string">"number"</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> num * num;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"类型错误，你应该传入一个数字..."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">33</span>))</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="string">"abc"</span>))</span><br></pre></td></tr></table></figure>
<h3 id="JavaScript-异常的收集"><a href="#JavaScript-异常的收集" class="headerlink" title="JavaScript 异常的收集"></a>JavaScript 异常的收集</h3><p>异常出现以后，会触发错误事件传递给window对象， 可以用 window.onerror = function(){}来捕抓页面上每一个错误，所以捕抓错误很简单。<br>我们要把我们需要的错误信息，post去我们的日志记录服务器那里，要做的：</p>
<p>整理需要记录的信息（包括，error属性，userAgent等）<br>error兼容性处理，不同浏览器error对象的属性会有差异，要做兼容处理<br>属性丢失，我们会想要收集些比较有用的信息包括：错误类型（name）、错误消息（message）、脚本文件地址（script）、行号（line)、列号（column）、堆栈跟踪（stack）。如果一个异常是通过 try-catch 捕获到的，这些信息都在 Error 对象上（主流浏览器都支持）。但如果是通过 window.onerror 捕获到的，我们都知道这个事件函数只有 3 个参数，所以这 3 个参数以外的信息就丢失了。<br>更多相关：<a href="https://www.jianshu.com/p/315ffe6797b8" target="_blank" rel="noopener">https://www.jianshu.com/p/315ffe6797b8</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/05/04/canvas/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YOLO">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/04/canvas/" itemprop="url">canvas</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-04T00:26:08+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>给大家简单介绍一下canvas在JS的用法及属性（如有介绍不到位 , 恳求各位大佬担待）;<br>目录</p>
<h3 id="一、Canvas简介"><a href="#一、Canvas简介" class="headerlink" title="一、Canvas简介"></a>一、Canvas简介</h3><h3 id="二、Canvas基本用法"><a href="#二、Canvas基本用法" class="headerlink" title="二、Canvas基本用法"></a>二、Canvas基本用法</h3><h3 id="三、填充和描边"><a href="#三、填充和描边" class="headerlink" title="三、填充和描边"></a>三、填充和描边</h3><h3 id="四、绘制矩形"><a href="#四、绘制矩形" class="headerlink" title="四、绘制矩形"></a>四、绘制矩形</h3><h3 id="五、绘制路径"><a href="#五、绘制路径" class="headerlink" title="五、绘制路径"></a>五、绘制路径</h3><ul>
<li>5.1、绘制线段</li>
<li>5.2、绘制三角形</li>
<li>5.3、绘制圆弧</li>
<li>5.4、绘制贝塞尔曲线</li>
</ul>
<h4 id="一、Canvas简-介"><a href="#一、Canvas简-介" class="headerlink" title="一、Canvas简 介"></a>一、Canvas简 介</h4><p>&lt;canvas&gt;元素是HTML5新增的，一个可以使用脚本( 通常为JavaScript )在其中绘制图像的HTML元素。它可以用来制作照片集制作简单的动画，甚至可以进行实时视频处理和渲染。<br>&lt;canvas&gt;由API构成，除了具备基本绘图能力的2D上下文，&lt;canvas&gt;还具备一个名为WebGL的3D上下文。</p>
<h4 id="二、Canvas基本用法-1"><a href="#二、Canvas基本用法-1" class="headerlink" title="二、Canvas基本用法"></a>二、Canvas基本用法</h4><p>使用&lt;canvas&gt;元素之前，必须先设置width和height属性，指定可以绘图( 画布 )的区域大小。<br>出现在开始和结束标签中的内容是后备信息，如果浏览器不支持&lt;canvas&gt;元素，就会显示这些信息。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span> = <span class="string">"drawing"</span> <span class="attr">width</span> = <span class="string">"600"</span> <span class="attr">height</span> = <span class="string">"600"</span>&gt;</span>A drwaing of something.<span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>要在这块画布上绘图，必须要使用getContext()方法传入参数”2d”取得2d上下文对象( 画笔 )。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var drawing = document.getElementById("drawing");</span><br><span class="line">//确定浏览器支持<span class="tag">&lt;<span class="name">canvas</span>&gt;</span>元素</span><br><span class="line">if（drawing.getContext &#123;</span><br><span class="line">        var ctx = drawing.getContext("2d");//取得2d上下文对象(画笔)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用2d绘图上下文提供方法，可以绘制简单的2d图形，比如矩形、弧线和路径等等。<br>2d上下文的坐标开始于&lt;canvas&gt;元素的左上角，原点坐标是（0，0）。<br>所有坐标值都基于这个原点计算，x值越大表示越靠右，y值越大越靠下。</p>
<h4 id="三、填充和描边-1"><a href="#三、填充和描边-1" class="headerlink" title="三、填充和描边"></a>三、填充和描边</h4><p>2d上下文的两种基本绘图操作是填充和描边。<br>填充就是指定的样式(颜色、渐变或图像) 填充图形，fill()默认为黑色，fillStyle = “任意颜色”。<br>描边就是图形边缘画线，*stroke()默认也是黑色，<br>strokeStyle = “任意颜色”来设置描边样式。<br>这两个属性的值可以是字符串、渐变对象或模式对象，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line"><span class="comment">//确定浏览器支持&lt;canvas&gt;元素</span></span><br><span class="line"><span class="keyword">if</span>(drawing.getContext) &#123;</span><br><span class="line"><span class="keyword">var</span> ctx = drawing.getContext(<span class="string">"2d"</span>);</span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line">ctx.fill();<span class="comment">//默认黑色</span></span><br><span class="line">ctx.fillStyle = <span class="string">"red"</span> <span class="comment">//设置为红色</span></span><br><span class="line"><span class="comment">//描边</span></span><br><span class="line">ctx.stroke();<span class="comment">//默认黑色</span></span><br><span class="line">ctx.strokeStyle = <span class="string">"green"</span><span class="comment">//设置为绿色</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="四、绘制矩形-1"><a href="#四、绘制矩形-1" class="headerlink" title="四、绘制矩形"></a>四、绘制矩形</h4><p>与绘制矩形有关的方法包括：<br>fillRect()<br>strokeRect()<br>clearRect()<br>这三个方法都是能接收四个参数：矩形的x坐标、矩形的y坐标矩形的width(宽)、矩形的height(高)，参数都是px(像素)。<br>示例1</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line"><span class="comment">//确定浏览器支持&lt;canvas&gt;元素</span></span><br><span class="line"><span class="keyword">if</span>(drawing.getContext) &#123;</span><br><span class="line"><span class="keyword">var</span> ctx = drawing.getContext(<span class="string">"2d"</span>);</span><br><span class="line"><span class="comment">//绘制红色矩形</span></span><br><span class="line">ctx.fillStyle  = <span class="string">"red"</span>;</span><br><span class="line">ctx.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/04/canvas/rectangle.webp" alt="矩形1"><br>示例2:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line"><span class="comment">//确定浏览器支持&lt;canvas&gt;元素</span></span><br><span class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>); <span class="comment">//取得2D上下文对象</span></span><br><span class="line">    <span class="comment">//绘制红色描边矩形</span></span><br><span class="line">    context.strokeStyle = <span class="string">"#F00"</span>;</span><br><span class="line">    context.strokeRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="comment">//绘制半透明的蓝色描边矩形</span></span><br><span class="line">    context.strokeStyle = <span class="string">"rgba(0, 0, 255, 0.5)"</span>;</span><br><span class="line">    context.strokeRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/04/canvas/rectangle2.webp" alt="矩形1"><br>示例3:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line"><span class="comment">//确定浏览器支持&lt;canvas&gt;元素</span></span><br><span class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>); <span class="comment">//取得2D上下文对象</span></span><br><span class="line">    <span class="comment">//绘制红色矩形</span></span><br><span class="line">    context.fillStyle = <span class="string">"#F00"</span>;</span><br><span class="line">    context.fillRect(<span class="number">10</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="comment">//绘制半透明的蓝色描边矩形</span></span><br><span class="line">    context.fillStyle = <span class="string">"rgba(0, 0, 255, 0.5)"</span>;</span><br><span class="line">    context.fillRect(<span class="number">30</span>, <span class="number">30</span>, <span class="number">50</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="comment">//在两个矩形重叠的地方清除一个小矩形</span></span><br><span class="line">    context.clearRect(<span class="number">40</span>, <span class="number">40</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/04/canvas/rectangle3.webp" alt="矩形1">  </p>
<h4 id="五、绘制路径-1"><a href="#五、绘制路径-1" class="headerlink" title="五、绘制路径"></a>五、绘制路径</h4><p>绘制方法:<br>·beginPath() ：表示要开始绘制新路径。<br>·moveTo()：起点坐标(x,y)。<br>·lineTo()：从起点坐标到开始绘制一条线，到(x,y)。<br>·rect(x,y,width,height)：从点(x,y)开始绘制一个  矩形，宽度和高度分别由width和height指定。这个方法绘制的是矩形路径，而不是strokeRect()和fillRect()所绘制的独立的形状。<br>·arc(x,y,r,start,end,flase||true)：以(x,y)为圆心绘制一条弧线，弧线半径为r，起始结束角度 (用弧线表示)分别为start和end。最后一个参数true和flase是否按逆时针方向计算，(值为true表示按逆时针计算)<br>·quadraticCurveTo(cx,cy,x,y)：绘制二次贝塞尔<br>·bezierCyrverTo(c1x,c1y,c2x,c2y,x,y)：绘制三次贝塞尔曲线。<br>·closePath()：绘制一条连接到路径起点的线条。<br>·fill()：使用fillStyle填充已经完成的路径<br>·stroke()：使用strokeStyle为已经完成的路径描边 </p>
<h5 id="5-1、绘制线段"><a href="#5-1、绘制线段" class="headerlink" title="5.1、绘制线段"></a>5.1、绘制线段</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line"><span class="comment">//确定浏览器支持&lt;canvas&gt;元素</span></span><br><span class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>); <span class="comment">//取得2D上下文对象</span></span><br><span class="line">    context.beginPath();        <span class="comment">//开始绘制新路径</span></span><br><span class="line">    context.moveTo(<span class="number">50</span>, <span class="number">50</span>);     <span class="comment">//把画笔移动到指定的坐标</span></span><br><span class="line">    context.lineTo(<span class="number">200</span>, <span class="number">50</span>);    <span class="comment">//绘制一条从当前位置到指定坐标(200, 50)的直线</span></span><br><span class="line">    context.stroke();           <span class="comment">//绘制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-2、绘制三角形"><a href="#5-2、绘制三角形" class="headerlink" title="5.2、绘制三角形"></a>5.2、绘制三角形</h5><p>绘制三角形边框：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line">       <span class="comment">//确定浏览器支持/&lt;canvas&gt;元素</span></span><br><span class="line">       <span class="keyword">if</span>(drawing.getContext)&#123;</span><br><span class="line">           <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>); <span class="comment">//取得2D上下文对象  </span></span><br><span class="line">           ctx.beginPath();           <span class="comment">//开始绘制新路径</span></span><br><span class="line">           ctx.moveTo(<span class="number">50</span>,<span class="number">50</span>);         <span class="comment">//把画笔移动到指定的坐标</span></span><br><span class="line">           ctx.lineTo(<span class="number">200</span>,<span class="number">50</span>);       <span class="comment">//绘制一条从坐标(50, 50)到坐标(200, 50)的直线</span></span><br><span class="line">           ctx.lineTo(<span class="number">200</span>,<span class="number">200</span>);    <span class="comment">//绘制一条从坐标(200, 50)到坐标(200, 200)的直线</span></span><br><span class="line">           ctx.closePath();      <span class="comment">//闭合路径，绘制一条从路径起点到路径终点的直线</span></span><br><span class="line">           ctx.stroke();       <span class="comment">//为路径描边</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/04/canvas/triangle.webp" alt="矩形1"><br>填充三角形：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line">       <span class="comment">//确定浏览器支持&lt;canvas&gt;元素</span></span><br><span class="line">       <span class="keyword">if</span>(drawing.getContext)&#123;</span><br><span class="line">           <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>); <span class="comment">//取得2D上下文对象</span></span><br><span class="line">           ctx.beginPath();           <span class="comment">//开始绘制新路径</span></span><br><span class="line">           ctx.moveTo(<span class="number">50</span>,<span class="number">50</span>);         <span class="comment">//把画笔移动到指定的坐标</span></span><br><span class="line">           ctx.lineTo(<span class="number">200</span>,<span class="number">50</span>);       <span class="comment">//绘制一条从坐标(50, 50)到坐标(200, 50)的直线</span></span><br><span class="line">           ctx.lineTo(<span class="number">200</span>,<span class="number">200</span>);    <span class="comment">//绘制一条从坐标(200, 50)到坐标(200, 200)的直线</span></span><br><span class="line">           ctx.closePath();      <span class="comment">//闭合路径，绘制一条从路径起点到路径终点的直线</span></span><br><span class="line">           ctx.stroke();       <span class="comment">//填充三角形</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/04/canvas/triangle2.webp" alt="矩形1"></p>
<h5 id="5-3、绘制圆弧"><a href="#5-3、绘制圆弧" class="headerlink" title="5.3、绘制圆弧"></a>5.3、绘制圆弧</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line"><span class="comment">//确定浏览器支持&lt;canvas&gt;元素</span></span><br><span class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>); <span class="comment">//取得2D上下文对象</span></span><br><span class="line">    context.beginPath();        <span class="comment">//开始绘制新路径</span></span><br><span class="line">    context.arc(<span class="number">100</span>, <span class="number">100</span>, <span class="number">99</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI, <span class="literal">false</span>);   </span><br><span class="line">    context.stroke();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-4、绘制贝塞尔曲线"><a href="#5-4、绘制贝塞尔曲线" class="headerlink" title="5.4、绘制贝塞尔曲线"></a>5.4、绘制贝塞尔曲线</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> drawing = <span class="built_in">document</span>.getElementById(<span class="string">"drawing"</span>);</span><br><span class="line"><span class="comment">//确定浏览器支持&lt;canvas&gt;元素</span></span><br><span class="line"><span class="keyword">if</span>(drawing.getContext)&#123;</span><br><span class="line">    <span class="keyword">var</span> context = drawing.getContext(<span class="string">"2d"</span>); <span class="comment">//取得2D上下文对象</span></span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.moveTo(<span class="number">10</span>, <span class="number">200</span>);    <span class="comment">//起始点</span></span><br><span class="line">    <span class="keyword">var</span> x1 = <span class="number">40</span>, y1 = <span class="number">100</span>;      <span class="comment">//控制点</span></span><br><span class="line">    <span class="keyword">var</span> x2 = <span class="number">200</span>, y2 = <span class="number">200</span>;     <span class="comment">//结束点</span></span><br><span class="line">    <span class="comment">//绘制贝塞尔曲线</span></span><br><span class="line">    context.quadraticCurveTo(x1, y1, x2, y2);</span><br><span class="line">    context.stroke();</span><br><span class="line">    context.beginPath();</span><br><span class="line">    context.rect(<span class="number">10</span>, <span class="number">200</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    context.rect(x1, y1, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    context.rect(x2, y2, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">    context.fill();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/04/canvas/wtf.webp" alt="buzhi"><br>链接：<a href="https://www.jianshu.com/p/01e94b6d5ce9" target="_blank" rel="noopener">https://www.jianshu.com/p/01e94b6d5ce9</a><br>来源：简书</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/10/%E5%9B%BE%E8%A7%A3http%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YOLO">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/10/%E5%9B%BE%E8%A7%A3http%E6%80%BB%E7%BB%93/" itemprop="url">图解http总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-10T16:20:31+08:00">
                2019-12-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-了解Web及网络基础"><a href="#1-了解Web及网络基础" class="headerlink" title="1 了解Web及网络基础"></a>1 了解Web及网络基础</h2><h3 id="1-1-使用HTTP协议访问Web"><a href="#1-1-使用HTTP协议访问Web" class="headerlink" title="1.1 使用HTTP协议访问Web"></a>1.1 使用HTTP协议访问Web</h3><p><strong>WWW构建技术</strong>:<br>1.SGML作为页面的文本标记语言的HTML<br>2.作为文档传递协议的HTTP<br>3.指定文档所在地址的URL </p>
<h3 id="1-3tcp-ip"><a href="#1-3tcp-ip" class="headerlink" title="1.3tcp/ip"></a>1.3tcp/ip</h3><h4 id="1-3-1TCP-IP协议族"><a href="#1-3-1TCP-IP协议族" class="headerlink" title="1.3.1TCP/IP协议族"></a>1.3.1TCP/IP协议族</h4><p>TCP/IP是互联网相关的各类协议族的总称  </p>
<h4 id="1-3-2TCP-IP的分层管理"><a href="#1-3-2TCP-IP的分层管理" class="headerlink" title="1.3.2TCP/IP的分层管理"></a>1.3.2TCP/IP的分层管理</h4><p>1.<strong>应用层</strong><br>向用户提供应用服务的通信活动 FTP(文件传输协议)DNS(域名系统)  HTTP在该层<br>2.<strong>传输层</strong><br>为应用层提供网络连接中的两台计算机之间的数据传输 TCP UDP<br>3.<strong>网络层</strong><br>处理网络上流动的数据包。 （规定传输路线到达对方计算机，并把数据包传送给的对方）（在众多选项内选择一条传输路线）  </p>
<p>4.<strong>链路层</strong>（网络接口层）<br>处理连接网络的硬件部分  </p>
<h4 id="1-3-3tcp-ip-通信传输流"><a href="#1-3-3tcp-ip-通信传输流" class="headerlink" title="1.3.3tcp/ip 通信传输流"></a>1.3.3tcp/ip 通信传输流</h4><p>发送端从应用层往下走，接收端则往应用层往上走<br><img src="./%E5%9B%BE%E8%A7%A3http%E6%80%BB%E7%BB%93/%E4%BC%A0%E8%BE%93%E6%B5%81.png" alt="传输流"><br>eg<br><img src="./%E5%9B%BE%E8%A7%A3http%E6%80%BB%E7%BB%93/http-example.png" alt="http-example">  </p>
<p>层与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信息。<br>这种把数据信息包装起来的做法称为封装</p>
<h3 id="1-4-IP-TCP-DNS协议"><a href="#1-4-IP-TCP-DNS协议" class="headerlink" title="1.4 IP TCP DNS协议"></a>1.4 IP TCP DNS协议</h3><p><strong>IP</strong>:位于网络层<br><strong>IP协议</strong>：把各种数据包传送给对方<br><strong>IP地址</strong>:指明节点被分配到的地址<br><strong>MAC地址</strong>:网卡所属的固定地址（ip变网卡一般不变）<br>ip之间的通信依赖MAC地址。通信双方在同一局域网中的情况是很少的，中转设备的MAC地址搜索下一个中转目标<br><strong>APR协议</strong>：解析地址的协议（通过通信双方的IP地址就可以反查处对应的MAC地址）<br><strong>TCP</strong>：传输层 提供可靠的字节流服务(将大块数据分割成以报文段为单位的数据包)。<br>三次握手策略：<img src="./%E5%9B%BE%E8%A7%A3http%E6%80%BB%E7%BB%93/three-way-handshaking.png" alt="三次握手">  </p>
<h3 id="1-5-DNS服务"><a href="#1-5-DNS服务" class="headerlink" title="1.5 DNS服务"></a>1.5 DNS服务</h3><p><strong>DNS</strong>：应用层<br>提供域名到IP地址之间的<strong>解析服务</strong>。<br>计算机一般通过域名或主机名来访问对方的计算机  </p>
<h3 id="1-7-URI-URL"><a href="#1-7-URI-URL" class="headerlink" title="1.7 URI URL"></a>1.7 URI URL</h3><p><strong>URI(统一资源标识符号)</strong>：标识某一互联网资源。<br><strong>URL()</strong>：资源的地点</p>
<h4 id="1-7-2-URI格式"><a href="#1-7-2-URI格式" class="headerlink" title="1.7.2 URI格式"></a>1.7.2 URI格式</h4><p><img src="./%E5%9B%BE%E8%A7%A3http%E6%80%BB%E7%BB%93/URI.png" alt="URI"><br>使用 http: 或 https: 等协议方案名获取访问资源时要指定协议类型。不<br>区分字母大小写,最后附一个冒号(:)。<br>也可使用 data: 或 javascript: 这类指定数据或脚本程序的方案名。<br>登录信息(认证)<br>指定用户名和密码作为从服务器端获取资源时必要的登录信息(身份<br>认证)。此项是可选项。  </p>
<ul>
<li>服务器地址<br>使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似<br>hackr.jp 这种 DNS 可解析的名称,或是 192.168.1.1 这类 IPv4 地址<br>名,还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。  </li>
<li>服务器端口号<br>指定服务器连接的网络端口号。此项也是可选项,若用户省略则自动使用默认端口号。  </li>
<li>带层次的文件路径<br>指定服务器上的文件路径来定位特指的资源。这与 UNIX 系统的文件查询字符串<br>针对已指定的文件路径内的资源,可以使用查询字符串传入任意参<br>数。此项可选。  </li>
<li>片段标识符<br>使用片段标识符通常可标记出已获取资源中的子资源(文档内的某个<br>位置)。但在 RFC 中并没有明确规定其使用方法。该项也为可选<br>项。  <h2 id="2-简单的HTTP协议"><a href="#2-简单的HTTP协议" class="headerlink" title="2 简单的HTTP协议"></a>2 简单的HTTP协议</h2><h3 id="2-2-通过请求和响应的交换达成通信"><a href="#2-2-通过请求和响应的交换达成通信" class="headerlink" title="2.2  通过请求和响应的交换达成通信"></a>2.2  通过请求和响应的交换达成通信</h3>请求报文是由请求方法、请求 URI、协议版本、可选的请求首部字段<br>和内容实体构成的。<br><img src="./%E5%9B%BE%E8%A7%A3http%E6%80%BB%E7%BB%93/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="请求报文"><br>http是一种不保存状态的协议 &gt;&gt;  引入cookie技术，管理状态  <h3 id="2-4-请求URI定位资源"><a href="#2-4-请求URI定位资源" class="headerlink" title="2.4 请求URI定位资源"></a>2.4 请求URI定位资源</h3>http协议使用URI定位互联网上的资源</li>
<li><em>请求URI的方法*</em>：  </li>
<li>URI为完整的请求URI ：’GET  <a href="http://hackr.jp/index.htmHTTP/1.1&#39;" target="_blank" rel="noopener">http://hackr.jp/index.htmHTTP/1.1&#39;</a></li>
<li>在首部字段Host中写明网络域名或IP地址’  </li>
</ul>
<p><strong>HTTP/1.1方法</strong><br>GET :获取资源<br>POST:传输实体主体<br>POST 的主要目的并不是获取响应的主体内容。<br>PUT:传输文件<br>HEAD:获得报文首部<br>DELETE :删除文件<br>OPTIONS:询问支持的方法  TRACE:追踪路径<br>CONNECT:要求用隧道协议连接代理<br>与代理服务器通信时建立隧道,实现用隧道协<br>议进行 TCP 通信  </p>
<h3 id="2-7持久连接节省通信量"><a href="#2-7持久连接节省通信量" class="headerlink" title="2.7持久连接节省通信量"></a>2.7持久连接节省通信量</h3><p>1持久连接：<br>目的:解决每次的请求都会造成无谓的 TCP 连接建立和断开<br>建立 1 次 TCP 连接后进行多次请求和响应的交互<br>2管线化技术:不用等待响应直接发送下一个请求<br>3使用cookie状态管理:<br>通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。  </p>
<ol>
<li>请求报文(没有 Cookie 信息的状态)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /reader/ HTTP/1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">*首部字段内没有Cookie的相关信息</span><br></pre></td></tr></table></figure></li>
<li>响应报文(服务器端生成 Cookie 信息)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 12 Jul 2012 07:12:20 GMT</span><br><span class="line">Server: Apache</span><br><span class="line">&lt;Set-Cookie: sid=1342077140226724; path=/; expires=Wed,</span><br><span class="line">10-Oct-12 07:12:20 GMT&gt;</span><br><span class="line">Content-Type: text/plain; charset=UTF-8</span><br></pre></td></tr></table></figure></li>
<li>请求报文(自动发送保存着的 Cookie 信息)<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /image/ HTTP/1.1</span><br><span class="line">Host: hackr.jp</span><br><span class="line">Cookie: sid=1342077140226724</span><br></pre></td></tr></table></figure>
<h2 id="3-HTTP-报文内的-HTTP信息"><a href="#3-HTTP-报文内的-HTTP信息" class="headerlink" title="3 HTTP 报文内的 HTTP信息"></a>3 HTTP 报文内的 HTTP信息</h2><h3 id="3-1http报文"><a href="#3-1http报文" class="headerlink" title="3.1http报文"></a>3.1http报文</h3></li>
</ol>
<p>HTTP协议交互的信息被称为http报文<br>请求端(客户端)的HTTP 报文叫做<strong>请求报文</strong>,响应端(服务器端)的叫做<strong>响应报文</strong>。<br>HTTP 报文大致可分为报文首部和报文主体两块<br><strong>报文首部</strong>：服务端或客户端需处理的请求或响应的内容及属性<br><strong>报文主体</strong>:应被发送的数据<br><img src="./%E5%9B%BE%E8%A7%A3http%E6%80%BB%E7%BB%93/%E6%8A%A5%E6%96%87.png" alt="请求报文和响应报文"></p>
<ul>
<li>请求行<br>包含用于请求的方法,请求 URI 和 HTTP 版本。  </li>
<li>状态行<br>包含表明响应结果的状态码,原因短语和 HTTP 版本。  </li>
<li>首部字段<br>包含表示请求和响应的各种条件和属性的各类首部。<br>一般有 4 种首部,分别是:通用首部、请求首部、响应首部和实体首部。  <h4 id="3-3-2-压缩传输的内容编码"><a href="#3-3-2-压缩传输的内容编码" class="headerlink" title="3.3.2 压缩传输的内容编码"></a>3.3.2 压缩传输的内容编码</h4>指明应用在实体内容上的编码格式。<br>常见的内容编码  <ul>
<li>gazip(GNUzip)  </li>
<li>compress(UNIX系统的标准压缩)  </li>
<li>deflate(zlib)</li>
<li>identity(不进行编码 <h4 id="3-3-3分割发送的分块（chunk）传输编码"><a href="#3-3-3分割发送的分块（chunk）传输编码" class="headerlink" title="3.3.3分割发送的分块（chunk）传输编码"></a>3.3.3分割发送的分块（chunk）传输编码</h4></li>
</ul>
</li>
<li><em>原因*</em>：在 HTTP 通信过程中,请求的编码实体资源尚未全部传输完成之前,浏览器无法显示请求页面。<br><strong>目地</strong>：能够让浏览器逐步显示页面。<br>使用分块传输编码的实体主体会由接收的客户端负责解码,恢复到编码前的实体主体。  <h3 id="3-4发送多种数据的多部分对象集合"><a href="#3-4发送多种数据的多部分对象集合" class="headerlink" title="3.4发送多种数据的多部分对象集合"></a>3.4发送多种数据的多部分对象集合</h3>MIME机制，邮件处理文本、图片、视频等多个不同类型数据。在 MIME 扩展中会使用一种称为<strong>多部分对象集合</strong>(Multipart)的方法,来容纳多不同类型的数据。<br>HTTP 协议中也采纳了多部分对象集合  </li>
<li>multipart/form-date<br>在 Web 表单文件上传时使用。  </li>
<li>multipart/byteranges  </li>
</ul>
<p>状态码 206(Partial Content,部分内容)响应报文包含了多个范围的内容时使用。<br><strong>提示</strong>：在 HTTP 报文中使用多部分对象集合时,需要在首部字段里加上Content-type。  </p>
<h3 id="3-5获取部分内容的范围请求"><a href="#3-5获取部分内容的范围请求" class="headerlink" title="3.5获取部分内容的范围请求"></a>3.5获取部分内容的范围请求</h3><p><strong>原因</strong>：如果下载过程中遇到网络中断的情况,那就必须重头开始。为了解决上述问题,需要一种<strong>可恢复的机制</strong>。  所谓恢复是指能从之前下载中断处恢复下载。<br><strong>方法</strong>：指定下载的实体范围。<br><strong>范围请求(Range Request)</strong>：指定范围发送的请求。<br>使用首部字段Range来指定资源的byte范围<br><strong>byte范围的制定形式</strong>：（自己查）<br>提示：对于多重范围的范围请求,响应会在首部字段 Content-Type 标明multipart/byteranges 后返回响应报文。  </p>
<h3 id="3-6内容协商返回最合适的内容"><a href="#3-6内容协商返回最合适的内容" class="headerlink" title="3.6内容协商返回最合适的内容"></a>3.6内容协商返回最合适的内容</h3><p><strong>内容协商机制</strong>：客户端和服务端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源<br><strong>判断依据</strong>：响应资源的语言，字符集，编码方式。<br><strong>三种内容协商技术</strong>  </p>
<ol>
<li>服务器驱动协商   </li>
<li>客户端驱动协商</li>
<li>透明协商<h2 id="4-返回结果的http状态玛"><a href="#4-返回结果的http状态玛" class="headerlink" title="4 返回结果的http状态玛"></a>4 返回结果的http状态玛</h2><h3 id="4-1-状态码告知从服务器端返回的请求结果"><a href="#4-1-状态码告知从服务器端返回的请求结果" class="headerlink" title="4.1 状态码告知从服务器端返回的请求结果"></a>4.1 状态码告知从服务器端返回的请求结果</h3>状态码类别：  <table>
<thead>
<tr>
<th align="left"></th>
<th align="left">类别</th>
<th align="left">原因短语</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1XX</td>
<td align="left">Informational(信息性状态码)</td>
<td align="left">接收的请求正在处理</td>
</tr>
<tr>
<td align="left">2XX</td>
<td align="left">Success(成功状态码)</td>
<td align="left">请求正常处理完毕</td>
</tr>
<tr>
<td align="left">3XX</td>
<td align="left">Redirection(重定向状态码)</td>
<td align="left">需要进行附加操作以完成请求</td>
</tr>
<tr>
<td align="left">4XX</td>
<td align="left">Client Error(客户端错误状态码)</td>
<td align="left">服务器无法处理请求</td>
</tr>
<tr>
<td align="left">5XX</td>
<td align="left">Server Error(服务器错误状态码)</td>
<td align="left">服务器处理请求出错</td>
</tr>
<tr>
<td align="left">具体 ……………………</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="5-与HTTP协作的Web服务器"><a href="#5-与HTTP协作的Web服务器" class="headerlink" title="5 与HTTP协作的Web服务器"></a>5 与HTTP协作的Web服务器</h2><h3 id="5-1-用单台虚拟主机实现多个域名"><a href="#5-1-用单台虚拟主机实现多个域名" class="headerlink" title="5.1 用单台虚拟主机实现多个域名"></a>5.1 用单台虚拟主机实现多个域名</h3><p>一个http服务器可以拥有多个Web站点。这是因为利用了虚拟主机的功能  .<br><strong>问题</strong>：因为同一台服务器托管了两个域名，用DNS服务解析域名后，两者的ip地址相同。<br><strong>解决办法</strong>：在发送http请求时，在Host首部内完整指定主机名或域名的URI  </p>
<h3 id="5-2-代理、网关、隧道"><a href="#5-2-代理、网关、隧道" class="headerlink" title="5.2 代理、网关、隧道"></a>5.2 代理、网关、隧道</h3><h4 id="5-2-1代理"><a href="#5-2-1代理" class="headerlink" title="5.2.1代理"></a>5.2.1代理</h4><p>代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。<br>源服务器：持有资源实体的服务器<br>via首部字段标记经过的主机信息<br><strong>代理的方法</strong>   </p>
<ul>
<li>缓存代理：预先将缓存保存在代理服务器上，接受到对相同资源的请求时，将缓存返回  。<br>若缓存失败，缓存服务器从源服务器上获取新资源。<br>缓存可以在客户端浏览器中</li>
<li>透明代理：部队报文进行加工  <h4 id="5-2-2-网关"><a href="#5-2-2-网关" class="headerlink" title="5.2.2 网关"></a>5.2.2 网关</h4></li>
</ul>
<p>由http请求转化为其他通信协议<br><img src="./%E5%9B%BE%E8%A7%A3http%E6%80%BB%E7%BB%93/%E7%BD%91%E5%85%B3.png" alt="网关"><br>提高通信的安全性</p>
<h4 id="5-2-3隧道"><a href="#5-2-3隧道" class="headerlink" title="5.2.3隧道"></a>5.2.3隧道</h4><p>隧道可按要求建立起一条与其他服务器的通信线路,届时使用 SSL 等加密手段进行通信<br>为了安全  </p>
<h2 id="6-HTTP首部"><a href="#6-HTTP首部" class="headerlink" title="6 HTTP首部"></a>6 HTTP首部</h2><h3 id="6-1-http报文首部"><a href="#6-1-http报文首部" class="headerlink" title="6.1 http报文首部"></a>6.1 http报文首部</h3><p>就很多</p>
<h2 id="7-https"><a href="#7-https" class="headerlink" title="7 https"></a>7 https</h2><p>http缺点：</p>
<ul>
<li>通信不加密，内容被窃听  </li>
<li>不验证身份，遭遇伪装  </li>
<li>无法证明完整，报文被篡改    </li>
</ul>
<p>窃听：收集在互联网上的流动的数据。解析工作交给那些抓包或嗅探器工具。<br><strong>防窃听</strong>：<br>1.加密</p>
<ul>
<li>通信加密 通过和 SSL(Secure Socket Layer,安全套接层)或TLS(Transport Layer Security,安全层传输协议)的组合使用,加密 HTTP 的通信内容。</li>
<li>内容加密 前提：客户uan端和服务器同时具有加密和解密的机制。  </li>
</ul>
<p>2.认证</p>
<ul>
<li>查明对手的证书 通过SSL。  </li>
</ul>
<p>3.完整性保护  </p>
<ul>
<li>MD5 和 SHA-1 等散列值校验的方法,以及用来确认文件的数字签名方法。  <h3 id="HTTP-加密-认证-完整性保护-HTTPS"><a href="#HTTP-加密-认证-完整性保护-HTTPS" class="headerlink" title="HTTP+ 加密 + 认证 + 完整性保护=HTTPS"></a>HTTP+ 加密 + 认证 + 完整性保护=HTTPS</h3>HTTP通信接口用SSL和TSL协议代替 =&gt; HTTPS有那些功能  </li>
<li><em>困境*</em>：共享密钥加密困难，通信被监听，密钥暴露  </li>
<li><em>方案*</em>： 公开加密技术，使用一对密钥，一把是密钥，另一把是公开密钥。发送密文使用对方的公开密钥，自己的私有密钥解密。<br>证明公开密钥正确性的证书<br>SSL的慢：通信慢和消耗CPU及内存等资源，处理速度慢  <h2 id="10-构建Web内容的技术"><a href="#10-构建Web内容的技术" class="headerlink" title="10 构建Web内容的技术"></a>10 构建Web内容的技术</h2>HTML CSS<br>DOM是用以操作HTML文档和XML文档的API,使用JavaScript等脚本语言对DOM的操作，可以更为见到你的方式控制HTML的改变<h3 id="WEB应用"><a href="#WEB应用" class="headerlink" title="WEB应用"></a>WEB应用</h3>由程序创建的内容动态内容<br>事先准备好的内容静态内 容    </li>
</ul>
<p><strong>CGI</strong><br><strong>Servet</strong><br><strong>XML</strong>SGML<br><strong>RSS/Atom</strong><br>ajax技术  <strong>JSON</strong>  </p>
<h2 id="6-HTTP首部-字段"><a href="#6-HTTP首部-字段" class="headerlink" title="6  HTTP首部 字段"></a>6  HTTP首部 字段</h2><h2 id="8-各种认证"><a href="#8-各种认证" class="headerlink" title="8 各种认证"></a>8 各种认证</h2><h2 id="9-基于HTTP的追加协议"><a href="#9-基于HTTP的追加协议" class="headerlink" title="9 基于HTTP的追加协议"></a>9 基于HTTP的追加协议</h2><h2 id="11-Web的攻击技术"><a href="#11-Web的攻击技术" class="headerlink" title="11 Web的攻击技术"></a>11 Web的攻击技术</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/09/%E6%B6%88%E9%99%A4%E9%97%B4%E9%9A%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="YOLO">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/09/%E6%B6%88%E9%99%A4%E9%97%B4%E9%9A%99/" itemprop="url">消除间隙</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-11-09T17:15:15+08:00">
                2019-11-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="一、产生间隙的原因"><a href="#一、产生间隙的原因" class="headerlink" title="一、产生间隙的原因"></a>一、产生间隙的原因</h3><p>书写html代码中，为了美观易读，标签结束后会回车换行，解析后会生成一个字符。    </p>
<p><img src="/2019/11/09/%E6%B6%88%E9%99%A4%E9%97%B4%E9%9A%99/%E9%97%B4%E9%9A%99%E5%9B%BE.png" alt="间隙图"><br><a href="(https://codepen.io/liaoyulu/pen/WNNzGGe)">链接</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></span><br><span class="line">    child&#123;</span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:50px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:50px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span><span class="selector-pseudo">:yellow</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">display</span><span class="selector-pseudo">:inline-block</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>一号<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>二号<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span> 三号<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>提示</strong>：在IE8-9，火狐，safari，chrome（在chrome下为8px）中，inline-block的元素之间存在“4px”的空白。</p>
<h3 id="二、消除间隙的方法"><a href="#二、消除间隙的方法" class="headerlink" title="二、消除间隙的方法"></a>二、消除间隙的方法</h3><h4 id="（1）移除标签间的空格（不建议）"><a href="#（1）移除标签间的空格（不建议）" class="headerlink" title="（1）移除标签间的空格（不建议）"></a>（1）移除标签间的空格（不建议）</h4><p>1.将代码写成一行   </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>一号<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>二号<span class="tag">&lt;/<span class="name">div</span>&gt;</span> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>三号<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>2.将上一行的结束标签与下一行的开始标签写在一起  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>一号<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">   二号<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span> 三号</span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.在两行代码之间加注释标签  </p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>一号<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">--&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>二号<span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">--&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>三号<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>4.标签不闭合</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>一号</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>二号</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>三号</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="（2）在font-size-0"><a href="#（2）在font-size-0" class="headerlink" title="（2）在font-size:0;"></a>（2）在font-size:0;</h4><p>给父元素设置font-size:0,给子元素设置字体大小.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:yellow;</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">14px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">font-size</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（3）负margin"><a href="#（3）负margin" class="headerlink" title="（3）负margin"></a>（3）负margin</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:yellow;</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">  <span class="attribute">margin</span>:-<span class="number">2px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于外部环境的不确定性，以及最后一个元素多出的负margin值等问题，这个方法不适合大规模使用。</p>
<h4 id="（4）letter-spacing"><a href="#（4）letter-spacing" class="headerlink" title="（4）letter-spacing"></a>（4）letter-spacing</h4><p>父元素</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">    <span class="attribute">letter-spacing</span>:<span class="number">0px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">letter-spacing</span>:-<span class="number">4px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（5）float-left"><a href="#（5）float-left" class="headerlink" title="（5）float:left"></a>（5）float:left</h4><p>一般文字图片混排用inline-block，如果页面整体布局就用float，用伪类after、before清除浮动即可.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.child</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>:<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">height</span>:<span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>:yellow;</span><br><span class="line">  <span class="attribute">display</span>:inline-block;</span><br><span class="line">  <span class="attribute">float</span>:left;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="selector-class">.parent</span><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">  <span class="attribute">content</span>:<span class="string">""</span>;</span><br><span class="line">   <span class="attribute">clear</span>:both;</span><br><span class="line">   <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line"> <span class="attribute">border</span>:<span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="（6）display-table和word-spacing"><a href="#（6）display-table和word-spacing" class="headerlink" title="（6）display:table和word-spacing"></a>（6）display:table和word-spacing</h4><p>一个是字符间距(letter-spacing)一个是单词间距(word-spacing)，word-spacing的负值只要大到一定程度，其兼容性上的差异就可以被忽略。因为，貌似，word-spacing即使负值很大，也不会发生重叠。<br>果您使用Chrome浏览器，可能看到的是间距依旧存在,可以添加display: table;或display:inline-table;</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">word-spacing</span>:-<span class="number">1em</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="三、补充"><a href="#三、补充" class="headerlink" title="三、补充"></a>三、补充</h3><p>有时候inline-block还会遇到顶部不在一个基准线的情况（垂直方向上产生的间隙<br><img src="/2019/11/09/%E6%B6%88%E9%99%A4%E9%97%B4%E9%9A%99/%E5%9E%82%E7%9B%B4%E9%97%B4%E9%9A%99.png" alt="垂直间隙"><br><strong>解决办法</strong>:  </p>
<ol>
<li>在每一个子元素上加一个属性vertical-align:top;(或者值是bottom,看具体效果)就在子元素上加vertical-align:bottom;</li>
<li>如果子标签内加上任意文字，则display:inline-block元素不会生成垂直方向有空白<h4 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h4></li>
<li><a href="https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/" target="_blank" rel="noopener">去除inline-block元素间间距的N种方法</a><br></li>
<li><a href="https://www.jb51.net/css/645772.html" target="_blank" rel="noopener">详解CSS 去掉inline-block元素间隙的几种方法</a>  </li>
<li><a href="https://blog.csdn.net/qq_32614411/article/details/82223624" target="_blank" rel="noopener">display:inline-block元素之间空隙的产生原因和解决办法</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
