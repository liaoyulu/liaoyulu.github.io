---
title: js111
date: 2020-08-02 13:14:43
tags:
---

## JS最新基本数据类型:BigInt
BigInt数据类型的目的是比Number数据类型支持的范围更大的整数值。在对大整数执行数学运算时，以任意精度表示整数的能力尤为重要。使用BigInt，整数溢出将不再是问题。

此外，可以安全地使用更加准确时间戳，大整数ID等，而无需使用变通方法。 BigInt目前是第3阶段提案， 一旦添加到规范中，它就是JS 第二个数字数据类型，也将是 JS 第8种基本数据类型：
对于学过其他语言的程序员来说，JS中缺少显式整数类型常常令人困惑。许多编程语言支持多种数字类型，如浮点型、双精度型、整数型和双精度型，但JS却不是这样。在JS中，按照IEEE 754-2008标准的定义，所有数字都以双精度64位浮点格式表示。

在此标准下，无法精确表示的非常大的整数将自动四舍五入。确切地说，JS 中的Number类型只能安全地表示-9007199254740991 (-(2^53-1)) 和9007199254740991(2^53-1)之间的整数，任何超出此范围的整数值都可能失去精度。
```js
coonsole.log(9999999999999999);    // → 10000000000000000)
该整数大于JS Number 类型所能表示的最大整数，因此，它被四舍五入的。意外四舍五入会损害程序的可靠性和安全性。这是另一个例子：

// 注意最后一位的数字
9007199254740992 === 9007199254740993;    // → true
```
### 解决方案
为了解决这些限制，一些JS开发人员使用字符串类型表示大整数。 例如，Twitter API 在使用 JSON 进行响应时会向对象添加字符串版本的 ID。 此外，还开发了许多库，例如 bignumber.js，以便更容易地处理大整数。

使用BigInt，应用程序不再需要变通方法或库来安全地表示Number.MAX_SAFE_INTEGER和Number.Min_SAFE_INTEGER之外的整数。 现在可以在标准JS中执行对大整数的算术运算，而不会有精度损失的风险。

要创建BigInt，只需在整数的末尾追加n即可。比较:
```js
console.log(9007199254740995n);    // → 9007199254740995n
console.log(9007199254740995);     // → 9007199254740996
```
或者，可以调用BigInt()构造函数
```js
BigInt("9007199254740995");    // → 9007199254740995n
BigInt文字也可以用二进制、八进制或十六进制表示

// binary
console.log(0b100000000000000000000000000000000000000000000000000011n);
// → 9007199254740995n

// hex
console.log(0x20000000000003n);
// → 9007199254740995n

// octal
console.log(0o400000000000000003n);
// → 9007199254740995n

// note that legacy octal syntax is not supported
console.log(0400000000000000003n);
// → SyntaxError
```
请记住，不能使用严格相等运算符将BigInt与常规数字进行比较，因为它们的类型不同：
```js
console.log(10n === 10);    // → false

console.log(typeof 10n);    // → bigint
console.log(typeof 10);     // → number
```
相反，可以使用等号运算符，它在处理操作数之前执行隐式类型转换
```js
console.log(10n == 10);    // → true
```
除一元加号(+)运算符外，所有算术运算符都可用于BigInt
```js
10n + 20n;    // → 30n
10n - 20n;    // → -10n
+10n;         // → TypeError: Cannot convert a BigInt value to a number
-10n;         // → -10n
10n * 20n;    // → 200n
20n / 10n;    // → 2n
23n % 10n;    // → 3n
10n ** 3n;    // → 1000n

const x = 10n;
++x;          // → 11n
--x;          // → 9n
```
不支持一元加号（+）运算符的原因是某些程序可能依赖于+始终生成Number的不变量，或者抛出异常。 更改+的行为也会破坏asm.js代码。

当然，与BigInt操作数一起使用时，算术运算符应该返回BigInt值。因此，除法(/)运算符的结果会自动向下舍入到最接近的整数。例如:

25 / 10;      // → 2.5
25n / 10n;    // → 2n

### 隐式类型转换
因为隐式类型转换可能丢失信息，所以不允许在bigint和 Number 之间进行混合操作。当混合使用大整数和浮点数时，结果值可能无法由BigInt或Number精确表示。思考下面的例子：

(9007199254740992n + 1n) + 0.5
这个表达式的结果超出了BigInt和Number的范围。小数部分的Number不能精确地转换为BigInt。大于2^53的BigInt不能准确地转换为数字。

由于这个限制，不可能对混合使用Number和BigInt操作数执行算术操作。还不能将BigInt传递给Web api和内置的 JS 函数，这些函数需要一个 Number 类型的数字。尝试这样做会报TypeError错误
```js
10 + 10n;    // → TypeError
Math.max(2n, 4n, 6n);    // → TypeError
```
请注意，关系运算符不遵循此规则，如下例所示：
```js
10n > 5;    // → true
```
如果希望使用BigInt和Number执行算术计算，首先需要确定应该在哪个类型中执行该操作。为此，只需通过调用Number()或BigInt()来转换操作数：
```js
BigInt(10) + 10n;    // → 20n
// or
10 + Number(10n);    // → 20
```
当 Boolean 类型与BigInt 类型相遇时，BigInt的处理方式与Number类似，换句话说，只要不是0n，BigInt就被视为truthy的值：
```js
if (5n) {
    // 这里代码块将被执行
}

if (0n) {
    // 这里代码块不会执行
}
```
排序BigInts和Numbers数组时，不会发生隐式类型转换：
```js
const arr = [3n, 4, 2, 1n, 0, -1n];

arr.sort();    // → [-1n, 0, 1n, 2, 3n, 4]
位操作符如|、&、<<、>>和^对Bigint的操作方式与Number类似。下面是一些例子

90 | 115;      // → 123
90n | 115n;    // → 123n
90n | 115;     // → TypeError
```
BigInt构造函数
与其他基本类型一样，可以使用构造函数创建BigInt。传递给BigInt()的参数将自动转换为BigInt:
```js
BigInt("10");    // → 10n
BigInt(10);      // → 10n
BigInt(true);    // → 1n
```
无法转换的数据类型和值会引发异常:
```js
BigInt(10.2);     // → RangeError
BigInt(null);     // → TypeError
BigInt("abc");    // → SyntaxError
```
可以直接对使用构造函数创建的BigInt执行算术操作

BigInt(10) * 10n;    // → 100n

使用严格相等运算符的操作数时，使用构造函数创建的Bigint与常规Bigint的处理方式类似
```js
BigInt(true) === 1n;    // → true
```
库函数
在撰写本文时，Chrome +67 和Opera +54完全支持BigInt数据类型。不幸的是，Edge和Safari还没有实现它。Firefox默认不支持BigInt，但是可以在about:config中将javascript.options.bigint 设置为true来开启它，最新支持的情况可在“Can I use”上查看。

不幸的是，转换BigInt是一个极其复杂的过程，这会导致严重的运行时性能损失。直接polyfill BigInt也是不可能的，因为该提议改变了几个现有操作符的行为。目前，更好的选择是使用JSBI库，它是BigInt提案的纯JS实现。

这个库提供了一个与原生BigInt行为完全相同的API。下面是如何使用JSBI：
```js
import JSBI from './jsbi.mjs';

const b1 = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
const b2 = JSBI.BigInt('10');

const result = JSBI.add(b1, b2);

console.log(String(result));    // → '9007199254741001'
```
使用JSBI的一个优点是，一旦浏览器支持，就不需要重写代码。 相反，可以使用babel插件自动将JSBI代码编译为原生 BigInt代码。

总结
BigInt是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。

重要的是要记住，不能使用Number和BigInt操作数的混合执行算术运算，需要通过显式转换其中的一种类型。 此外，出于兼容性原因，不允许在BigInt上使用一元加号（+）运算符。
来源：https://segmentfault.com/a/1190000019912017
## for in 与 Object.keys 与 hasOwnProperty区别

1、结论

for in遍历对象所有可枚举属性 包括原型链上的属性

Object.keys遍历对象所有可枚举属性 不包括原型链上的属性

hasOwnProperty 检查对象是否包含属性名，无法检查原型链上是否具有此属性名

1.在某个对象是否拥有某个属性，判断的方法有很多，常用的方法就是object.hasOwnProperty('×××')，这个方法是不包括对象原型链上的方法的，举个例子：
```js
var obj = {
    name:'fei'
}
    console.log(obj.hasOwnProperty('name'))//true
    console.log(obj.hasOwnProperty('toString'))//false
```
在这个例子中，obj对象存在的name属性的时候，调用这个方法才是返回true，我们知道其实每个对象实例的原型链上存在toString方法，在这里打印false，说明这个方法只是表明实例对象的属性，不包括原型链上的属性。

　2.下面我们再来看看in的使用，例子如下：

```js
var obj = {
     name:'fei'
}
    console.log('toString' in obj)//true
```
我们可以看到，其实在这个例子中，我只是给了对象一个属性name，并没有其他的属性，然后我执行'tiString' in obj，可以看出控制动态打印出来的是true，原因就是对象的原型链上存在toString方法，所以in操作不管是不是原型链上，只要存在这个属性，返回的就是true。
3.接着我们再看for in。在使用for in 循环的时候，其实返回的是能通过对象访问的，可枚举的，包括实例中的，也包括原型中的，例子如下
```js
var obj = {
      name:'fei',
      age:20,
      friend:["fei","jun","zhu"]
}
for( var i in obj){
      console.log(i)//会打印三次，name，age，friend
}
```
为什么上面没有打印原型中的属性呢，因为原型中的属性都默认设置了不可枚举（enumerated）；我们将例子改成下面这样：
```js
var obj = {
      name:'fei',
      age:20,
      friend:["fei","jun","zhu"]
}
 Object.defineProperty(obj, 'like', {//使用Object.defineProperty()方法可以设置你设置属性的特性
      enumerable:false,//设置不可枚举
      value:'basketball'//值为basketball
 })
console.log(obj)//Object {name: "fei", age: 20, friend: Array[3], like: "basketball"}
 
for(var i in obj){
     console.log(i)//依旧打印三个name,age,friend
}
```
从这个例子中可以看出，在给属性设置为不可枚举的时候，是不会出现在for in循环中的，这也造成IE低版本出现bug，就是不可枚举的属性不会出现在for in中，如果你从新定义了一个属性和原型的属性相同，那么这个属性也不会出现在for in中，现在的浏览器不会出现，例子如下：
```js
var obj = {
        toString:function(){
               return "666"
        }
}
 for(var i in obj){
       if(i=="toString"){
              console.log('我出现了') //在低版本的IE中不显示
        }
}
```
4.要取得所有可枚举的对象，可以使用ECMAscript5的方法Object.keys(),接受一个对象为参数，返回所有可枚举的属性的字符串数组：
```js
function People(){
 
}
People.prototype.say = function(){
        console.log('say')
}
People.prototype.name = "feifei";
 
var people = new People()
people.age = 12;
 
console.log(Object.keys(people))//['age']
```
这个方法并不会包含原型链中的属性，只是实例中的可枚举的属性。

5.获取实例中所有属性，无论是否可枚举，利用Object.getOwnPropertyNames(),以对象为参数，返回熟悉的数组。例子：

```js
function People(){
 
}
People.prototype.say = function(){
      console.log('say')
}
People.prototype.name = "feifei";
 
var people = new People()
people.age = 12;
Object.defineProperty(people, 'like', {//使用Object.defineProperty()方法可以设置你设置属性的特性
      enumerable:false,//设置不可枚举
      value:'basketball'//值为basketball
})
console.log(people)//People {age: 12, like: "basketball"}
console.log(Object.getOwnPropertyNames(people))//["age", "like"]
```
这个方法仅仅是返回实例中所有的属性，无论是不是可枚举的，不包括原型里面的属性。
3、ESLINT对for in的限制

当你在某个对象上用 for in 语句遍历对象属性，而又忘了用 hasOwnProperty 判断属性来源的时候，你就会发现被你扩展的原型属性也会被遍历出来，这往往都不是我们想要的结果。

总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替。

ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用。
```js
let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // 'a', 'b', 'c'
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]
}
```
来源：https://www.cnblogs.com/zhenfei-jiang/p/7028686.html
https://www.cnblogs.com/xbcq/p/5649575.
## 将字符串变成数组的方法
#### 一）、es5的方法
1、split()
用指定的分隔符把一个字符串分割存储到数组
```js
let arr2 =s.split("")
console.log("方法2：",arr2);
// [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ]
```
2、slice()
从当前数组中截取一个子数组并且返回
```js
//因为slice是数组中的方法，所以要用call使this指向s

let arr5 = Array.prototype.slice.call(s);
console.log("方法5：",arr5);
// [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ]
```

### 二）、es6的方法
3、rest
…obj 将对象中成员剥离出来

let s ="hello world";
```js
//这里的用法是先将字符串的每一个字符剥离出来，再存放到数组里
let arr =[...s]
console.log("方法1：",arr);
// [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ]
```
4、Object.values()
这个方法是返回一个数组，数组成员是原先对象的所有属性值
```js
let arr3 = Object.values(s);
console.log("方法3：",arr3);
// [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ]
```
5、Array.from()
将类数组对象或者可遍历的对象转为真正数组
```js
let arr4 = Array.from(s);
console.log("方法4：",arr4);
// [ 'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd' ]
```
原文链接：https://blog.csdn.net/hxrykl/java/article/details/102497596
## js中[]和{}和()的区别  
### 一、{ } 大括号，表示定义一个对象，大部分情况下要有成对的属性和值，或是函数体  
{}表示对象、[]表示对象的属性、方法,()如果用在方法名后面，代表调用
如：var LangShen = {"Name":"Langshen","AGE":”28”}; 
上面声明了一个名为“LangShen”的对象，多个属性或函数用,（逗号）隔开，因为是对象的属性， 
所以访问时，应该用.（点）来层层访问：LangShen.Name、LangShen.AGE，
当然我们也可以用数组的方式来访问，如：LangShen["Name"]、LangShen["AGE"]，结果是一样的。
```js
var LangShen = { 
    Name : function(){ 
        return "LangShen"; 
    }, 
    Age : function(){ 
        return "28"; 
    } 
} 
调用 LangShen.Name()
```
### 二、[ ]中括号，表示一个数组，也可以理解为一个数组对象
如：var LangShen = [ "Name","LangShen","AGE","28" ]; 
很明显，每个值或函数，都是独立的，多个值之间只用,（逗号）隔开，因为是数组对象，所以它等于： 
var LangShen = Array( "Name","LangShen","AGE","28" ); 
访问时，也是和数组一样，alert( LangShen[0] )
### 三、{ } 和[ ] 一起使用，我们前面说到，{ } 是一个对象，[ ] 是一个数组，我们可以组成一个对象数组
```js
var LangShen = { 
    "Name":"Langshen", 
    "MyWife":[ "LuLu","26" ], 
    "MySon":[{"Name":"Son1"},{"Name":"Son2"},{"Name":"Son3"}] 
} 
从上面的结构来看，是一个对象里面的第一项是个属性，第二项是一个数组，第三个是包含有多个对象的数组。
调用起来，也是一层一层访问，对象的属性用.（点）叠加，数组用 [下标] 来访问。 
如：alert( LangShen.MySon[1].Name ) ；
var LangShen=[
    {“name”：“wangwu”},
    {“name”：“lieu”}
];
这是一个对象数组
```
### 四、()多表示参数、{}表示函数体  ()要看它放在什么位置才能知道它起什么作用，因为它有多种用法
```js
function show(name){
    Alert(name);
}
es6中，
let show=(name)=>{
    alert(name);
}
在es6中如果参数只有一个，或者函数体只有一个话，可以省略（）、{},如
let show=name=>alert(name);
```
来源：https://www.cnblogs.com/mike-mei/p/11194138.html








